2021-04-25 19:04:08.459  INFO 19964 --- [restartedMain] com.yi.blog.BlogApplication              : Starting BlogApplication on LAPTOP-P12KV1HJ with PID 19964 (D:\blog\lyric\target\classes started by lyric in D:\blog)
2021-04-25 19:04:08.514 DEBUG 19964 --- [restartedMain] com.yi.blog.BlogApplication              : Running with Spring Boot v2.1.8.RELEASE, Spring v5.1.9.RELEASE
2021-04-25 19:04:08.515  INFO 19964 --- [restartedMain] com.yi.blog.BlogApplication              : No active profile set, falling back to default profiles: default
2021-04-25 19:04:08.568  INFO 19964 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2021-04-25 19:04:08.569  INFO 19964 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2021-04-25 19:04:10.171  INFO 19964 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
2021-04-25 19:04:10.194  INFO 19964 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2021-04-25 19:04:10.195  INFO 19964 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.24]
2021-04-25 19:04:10.298  INFO 19964 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2021-04-25 19:04:10.298  INFO 19964 --- [restartedMain] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1729 ms
2021-04-25 19:04:10.831  WARN 19964 --- [restartedMain] c.b.m.core.metadata.TableInfoHelper      : Warn: Could not find @TableId in Class: com.yi.blog.entity.BlogTags.
2021-04-25 19:04:11.944  INFO 19964 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2021-04-25 19:04:12.083  INFO 19964 --- [restartedMain] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2021-04-25 19:04:12.447  INFO 19964 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2021-04-25 19:04:12.498  INFO 19964 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2021-04-25 19:04:12.503  INFO 19964 --- [restartedMain] com.yi.blog.BlogApplication              : Started BlogApplication in 4.692 seconds (JVM running for 5.686)
2021-04-25 19:04:21.711  INFO 19964 --- [http-nio-8080-exec-2] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2021-04-25 19:04:21.711  INFO 19964 --- [http-nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2021-04-25 19:04:21.723  INFO 19964 --- [http-nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : Completed initialization in 12 ms
2021-04-25 19:04:21.754  INFO 19964 --- [http-nio-8080-exec-2] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.index', args=[{}, org.apache.catalina.connector.ResponseFacade@267d67fa]}
2021-04-25 19:04:21.792  INFO 19964 --- [http-nio-8080-exec-2] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2021-04-25 19:04:21.988  INFO 19964 --- [http-nio-8080-exec-2] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2021-04-25 19:04:22.021 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.m.B.selectPageByTitleAndType       : ==>  Preparing: SELECT COUNT(1) FROM blog WHERE 1 = 1 
2021-04-25 19:04:22.039 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.m.B.selectPageByTitleAndType       : ==> Parameters: 
2021-04-25 19:04:22.066 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.m.B.selectPageByTitleAndType       : ==>  Preparing: SELECT * FROM blog WHERE 1 = 1 ORDER BY update_time DESC LIMIT ?,? 
2021-04-25 19:04:22.067 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.m.B.selectPageByTitleAndType       : ==> Parameters: 0(Long), 8(Long)
2021-04-25 19:04:22.098 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.mapper.BlogTypeMapper.getBlogType  : ====>  Preparing: select * from blog_type where id = ? 
2021-04-25 19:04:22.099 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.mapper.BlogTypeMapper.getBlogType  : ====> Parameters: 14(Long)
2021-04-25 19:04:22.109 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.mapper.BlogTypeMapper.getBlogType  : <====      Total: 1
2021-04-25 19:04:22.112 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.m.B.selectPageByTitleAndType       : <==      Total: 4
2021-04-25 19:04:22.118 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.m.BlogTypeMapper.listBlogType      : ==>  Preparing: SELECT bt.*, b.id b_id FROM blog_type bt LEFT JOIN blog b ON bt.id = b.blog_type_id 
2021-04-25 19:04:22.119 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.m.BlogTypeMapper.listBlogType      : ==> Parameters: 
2021-04-25 19:04:22.131 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.m.BlogTypeMapper.listBlogType      : <==      Total: 4
2021-04-25 19:04:22.136 DEBUG 19964 --- [http-nio-8080-exec-2] com.yi.blog.mapper.TagMapper.listTag     : ==>  Preparing: SELECT t.*, bt.blog_id FROM tag t LEFT JOIN blog_tags bt ON t.id = bt.tag_id 
2021-04-25 19:04:22.136 DEBUG 19964 --- [http-nio-8080-exec-2] com.yi.blog.mapper.TagMapper.listTag     : ==> Parameters: 
2021-04-25 19:04:22.148 DEBUG 19964 --- [http-nio-8080-exec-2] com.yi.blog.mapper.TagMapper.listTag     : <==      Total: 5
2021-04-25 19:04:22.167 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:04:22.168 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:04:22.179 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:04:22.191 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.UserMapper.updateById   : ==>  Preparing: UPDATE user SET nickname=?, username=?, password=?, qq=?, wechat=?, email=?, province=?, city=?, avatar=?, views=?, create_time=?, update_time=?, user_signature=? WHERE id=? 
2021-04-25 19:04:22.193 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.UserMapper.updateById   : ==> Parameters: lyric(String), lyric(String), 96e79218965eb72c92a549dd5a330112(String), 2044619214(String), 17805428855(String), lyric0926@163.com(String), 浙江(String), 杭州(String), /images/user.jpg(String), 45825(Integer), 2020-09-02 15:16:51.0(Timestamp), 2021-04-02 00:55:48.5(Timestamp), 你生命中最美好的一天，就是你决定让你的人生属于你自己的那一天。(String), 1(Long)
2021-04-25 19:04:22.213 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.UserMapper.updateById   : <==    Updates: 1
2021-04-25 19:04:22.243  INFO 19964 --- [http-nio-8080-exec-2] com.yi.blog.aspect.LogAspect             : Result:index
2021-04-25 19:04:23.143  INFO 19964 --- [http-nio-8080-exec-1] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/footer/newBlog', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.newblogs', args=[{}]}
2021-04-25 19:04:23.143  INFO 19964 --- [http-nio-8080-exec-1] com.yi.blog.aspect.LogAspect             : Result:_fragments :: newBlogList
2021-04-25 19:04:26.980  INFO 19964 --- [http-nio-8080-exec-2] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/archives;jsessionid=4CBAC6B7F2280496780589C3DF37354F', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.ArchiveShowController.archives', args=[{}]}
2021-04-25 19:04:26.994 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.m.BlogTypeMapper.listBlogType      : ==>  Preparing: SELECT bt.*, b.id b_id FROM blog_type bt LEFT JOIN blog b ON bt.id = b.blog_type_id 
2021-04-25 19:04:26.994 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.m.BlogTypeMapper.listBlogType      : ==> Parameters: 
2021-04-25 19:04:27.007 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.m.BlogTypeMapper.listBlogType      : <==      Total: 4
2021-04-25 19:04:27.008 DEBUG 19964 --- [http-nio-8080-exec-2] com.yi.blog.mapper.TagMapper.listTag     : ==>  Preparing: SELECT t.*, bt.blog_id FROM tag t LEFT JOIN blog_tags bt ON t.id = bt.tag_id 
2021-04-25 19:04:27.008 DEBUG 19964 --- [http-nio-8080-exec-2] com.yi.blog.mapper.TagMapper.listTag     : ==> Parameters: 
2021-04-25 19:04:27.020 DEBUG 19964 --- [http-nio-8080-exec-2] com.yi.blog.mapper.TagMapper.listTag     : <==      Total: 5
2021-04-25 19:04:27.021 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.mapper.BlogMapper.findGroupYear    : ==>  Preparing: SELECT DATE_FORMAT( b.update_time, '%Y' ) year FROM blog b GROUP BY DATE_FORMAT( b.update_time, '%Y' ) ORDER BY year DESC 
2021-04-25 19:04:27.021 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.mapper.BlogMapper.findGroupYear    : ==> Parameters: 
2021-04-25 19:04:27.032 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.mapper.BlogMapper.findGroupYear    : <==      Total: 1
2021-04-25 19:04:27.034 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.BlogMapper.findByYear   : ==>  Preparing: SELECT b.* FROM blog b WHERE DATE_FORMAT( b.update_time, '%Y' ) = ? 
2021-04-25 19:04:27.034 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.BlogMapper.findByYear   : ==> Parameters: 2021(String)
2021-04-25 19:04:27.059 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.BlogMapper.findByYear   : <==      Total: 4
2021-04-25 19:04:27.060  INFO 19964 --- [http-nio-8080-exec-2] com.yi.blog.aspect.LogAspect             : Result:archives
2021-04-25 19:04:28.438  INFO 19964 --- [http-nio-8080-exec-9] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.index', args=[{}, org.apache.catalina.connector.ResponseFacade@644f0d11]}
2021-04-25 19:04:28.450 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.m.B.selectPageByTitleAndType       : ==>  Preparing: SELECT COUNT(1) FROM blog WHERE 1 = 1 
2021-04-25 19:04:28.450 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.m.B.selectPageByTitleAndType       : ==> Parameters: 
2021-04-25 19:04:28.462 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.m.B.selectPageByTitleAndType       : ==>  Preparing: SELECT * FROM blog WHERE 1 = 1 ORDER BY update_time DESC LIMIT ?,? 
2021-04-25 19:04:28.462 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.m.B.selectPageByTitleAndType       : ==> Parameters: 0(Long), 8(Long)
2021-04-25 19:04:28.488 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.mapper.BlogTypeMapper.getBlogType  : ====>  Preparing: select * from blog_type where id = ? 
2021-04-25 19:04:28.488 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.mapper.BlogTypeMapper.getBlogType  : ====> Parameters: 14(Long)
2021-04-25 19:04:28.498 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.mapper.BlogTypeMapper.getBlogType  : <====      Total: 1
2021-04-25 19:04:28.499 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.m.B.selectPageByTitleAndType       : <==      Total: 4
2021-04-25 19:04:28.500 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.m.BlogTypeMapper.listBlogType      : ==>  Preparing: SELECT bt.*, b.id b_id FROM blog_type bt LEFT JOIN blog b ON bt.id = b.blog_type_id 
2021-04-25 19:04:28.500 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.m.BlogTypeMapper.listBlogType      : ==> Parameters: 
2021-04-25 19:04:28.510 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.m.BlogTypeMapper.listBlogType      : <==      Total: 4
2021-04-25 19:04:28.511 DEBUG 19964 --- [http-nio-8080-exec-9] com.yi.blog.mapper.TagMapper.listTag     : ==>  Preparing: SELECT t.*, bt.blog_id FROM tag t LEFT JOIN blog_tags bt ON t.id = bt.tag_id 
2021-04-25 19:04:28.511 DEBUG 19964 --- [http-nio-8080-exec-9] com.yi.blog.mapper.TagMapper.listTag     : ==> Parameters: 
2021-04-25 19:04:28.521 DEBUG 19964 --- [http-nio-8080-exec-9] com.yi.blog.mapper.TagMapper.listTag     : <==      Total: 5
2021-04-25 19:04:28.533 DEBUG 19964 --- [http-nio-8080-exec-9] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:04:28.533 DEBUG 19964 --- [http-nio-8080-exec-9] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:04:28.544 DEBUG 19964 --- [http-nio-8080-exec-9] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:04:28.546 DEBUG 19964 --- [http-nio-8080-exec-9] c.yi.blog.mapper.UserMapper.updateById   : ==>  Preparing: UPDATE user SET nickname=?, username=?, password=?, qq=?, wechat=?, email=?, province=?, city=?, avatar=?, views=?, create_time=?, update_time=?, user_signature=? WHERE id=? 
2021-04-25 19:04:28.547 DEBUG 19964 --- [http-nio-8080-exec-9] c.yi.blog.mapper.UserMapper.updateById   : ==> Parameters: lyric(String), lyric(String), 96e79218965eb72c92a549dd5a330112(String), 2044619214(String), 17805428855(String), lyric0926@163.com(String), 浙江(String), 杭州(String), /images/user.jpg(String), 45826(Integer), 2020-09-02 15:16:51.0(Timestamp), 2021-04-02 00:55:48.5(Timestamp), 你生命中最美好的一天，就是你决定让你的人生属于你自己的那一天。(String), 1(Long)
2021-04-25 19:04:28.567 DEBUG 19964 --- [http-nio-8080-exec-9] c.yi.blog.mapper.UserMapper.updateById   : <==    Updates: 1
2021-04-25 19:04:28.596  INFO 19964 --- [http-nio-8080-exec-9] com.yi.blog.aspect.LogAspect             : Result:index
2021-04-25 19:04:28.880  INFO 19964 --- [http-nio-8080-exec-8] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/footer/newBlog', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.newblogs', args=[{}]}
2021-04-25 19:04:28.880  INFO 19964 --- [http-nio-8080-exec-8] com.yi.blog.aspect.LogAspect             : Result:_fragments :: newBlogList
2021-04-25 19:04:29.876  INFO 19964 --- [http-nio-8080-exec-9] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/blog/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.blog', args=[37, {}]}
2021-04-25 19:04:29.908 DEBUG 19964 --- [http-nio-8080-exec-9] com.yi.blog.mapper.UserMapper.selectOne  : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE (id = ?) 
2021-04-25 19:04:29.909 DEBUG 19964 --- [http-nio-8080-exec-9] com.yi.blog.mapper.UserMapper.selectOne  : ==> Parameters: 1(Integer)
2021-04-25 19:04:29.919 DEBUG 19964 --- [http-nio-8080-exec-9] com.yi.blog.mapper.UserMapper.selectOne  : <==      Total: 1
2021-04-25 19:04:29.930 DEBUG 19964 --- [http-nio-8080-exec-9] c.yi.blog.mapper.BlogMapper.selectById   : ==>  Preparing: SELECT id,title,content,first_picture,stamp,views,appreciate,original,comments,published,recommend,create_time,update_time,blog_type_id,user_id FROM blog WHERE id=? 
2021-04-25 19:04:29.930 DEBUG 19964 --- [http-nio-8080-exec-9] c.yi.blog.mapper.BlogMapper.selectById   : ==> Parameters: 37(Long)
2021-04-25 19:04:29.942 DEBUG 19964 --- [http-nio-8080-exec-9] c.yi.blog.mapper.BlogMapper.selectById   : <==      Total: 1
2021-04-25 19:04:29.945 DEBUG 19964 --- [http-nio-8080-exec-9] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:04:29.946 DEBUG 19964 --- [http-nio-8080-exec-9] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:04:29.955 DEBUG 19964 --- [http-nio-8080-exec-9] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:04:29.961 DEBUG 19964 --- [http-nio-8080-exec-9] c.yi.blog.mapper.BlogMapper.updateById   : ==>  Preparing: UPDATE blog SET title=?, content=?, stamp=?, views=?, appreciate=?, original=?, comments=?, published=?, recommend=?, create_time=?, update_time=?, blog_type_id=?, user_id=? WHERE id=? 
2021-04-25 19:04:29.962 DEBUG 19964 --- [http-nio-8080-exec-9] c.yi.blog.mapper.BlogMapper.updateById   : ==> Parameters: aaaaaaa(String), ![描述描述](http://gulimall-lyric.oss-cn-qingdao.aliyuncs.com/hello.jpeg "描述描述")![]( https://gulimall-lyric.oss-cn-qingdao.aliyuncs.com/wallhaven-6k3oox.jpg)(String), 原创(String), 3(Integer), false(Boolean), false(Boolean), false(Boolean), true(Boolean), false(Boolean), 2021-04-25 15:38:36.494(Timestamp), 2021-04-25 15:40:16.551(Timestamp), 14(Long), 1(Long), 37(Long)
2021-04-25 19:04:29.981 DEBUG 19964 --- [http-nio-8080-exec-9] c.yi.blog.mapper.BlogMapper.updateById   : <==    Updates: 1
2021-04-25 19:04:30.052  INFO 19964 --- [http-nio-8080-exec-9] com.yi.blog.aspect.LogAspect             : Result:archivedetails
2021-04-25 19:06:05.216  INFO 19964 --- [http-nio-8080-exec-7] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/archives', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.ArchiveShowController.archives', args=[{}]}
2021-04-25 19:06:05.227 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.BlogTypeMapper.listBlogType      : ==>  Preparing: SELECT bt.*, b.id b_id FROM blog_type bt LEFT JOIN blog b ON bt.id = b.blog_type_id 
2021-04-25 19:06:05.228 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.BlogTypeMapper.listBlogType      : ==> Parameters: 
2021-04-25 19:06:05.238 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.BlogTypeMapper.listBlogType      : <==      Total: 4
2021-04-25 19:06:05.239 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.TagMapper.listTag     : ==>  Preparing: SELECT t.*, bt.blog_id FROM tag t LEFT JOIN blog_tags bt ON t.id = bt.tag_id 
2021-04-25 19:06:05.240 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.TagMapper.listTag     : ==> Parameters: 
2021-04-25 19:06:05.250 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.TagMapper.listTag     : <==      Total: 5
2021-04-25 19:06:05.251 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.mapper.BlogMapper.findGroupYear    : ==>  Preparing: SELECT DATE_FORMAT( b.update_time, '%Y' ) year FROM blog b GROUP BY DATE_FORMAT( b.update_time, '%Y' ) ORDER BY year DESC 
2021-04-25 19:06:05.251 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.mapper.BlogMapper.findGroupYear    : ==> Parameters: 
2021-04-25 19:06:05.261 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.mapper.BlogMapper.findGroupYear    : <==      Total: 1
2021-04-25 19:06:05.263 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.BlogMapper.findByYear   : ==>  Preparing: SELECT b.* FROM blog b WHERE DATE_FORMAT( b.update_time, '%Y' ) = ? 
2021-04-25 19:06:05.263 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.BlogMapper.findByYear   : ==> Parameters: 2021(String)
2021-04-25 19:06:05.289 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.BlogMapper.findByYear   : <==      Total: 4
2021-04-25 19:06:05.290  INFO 19964 --- [http-nio-8080-exec-7] com.yi.blog.aspect.LogAspect             : Result:archives
2021-04-25 19:06:06.291  INFO 19964 --- [http-nio-8080-exec-7] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.index', args=[{}, org.apache.catalina.connector.ResponseFacade@267d67fa]}
2021-04-25 19:06:06.302 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.B.selectPageByTitleAndType       : ==>  Preparing: SELECT COUNT(1) FROM blog WHERE 1 = 1 
2021-04-25 19:06:06.303 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.B.selectPageByTitleAndType       : ==> Parameters: 
2021-04-25 19:06:06.313 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.B.selectPageByTitleAndType       : ==>  Preparing: SELECT * FROM blog WHERE 1 = 1 ORDER BY update_time DESC LIMIT ?,? 
2021-04-25 19:06:06.314 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.B.selectPageByTitleAndType       : ==> Parameters: 0(Long), 8(Long)
2021-04-25 19:06:06.339 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.mapper.BlogTypeMapper.getBlogType  : ====>  Preparing: select * from blog_type where id = ? 
2021-04-25 19:06:06.339 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.mapper.BlogTypeMapper.getBlogType  : ====> Parameters: 14(Long)
2021-04-25 19:06:06.350 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.mapper.BlogTypeMapper.getBlogType  : <====      Total: 1
2021-04-25 19:06:06.351 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.B.selectPageByTitleAndType       : <==      Total: 4
2021-04-25 19:06:06.353 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.BlogTypeMapper.listBlogType      : ==>  Preparing: SELECT bt.*, b.id b_id FROM blog_type bt LEFT JOIN blog b ON bt.id = b.blog_type_id 
2021-04-25 19:06:06.353 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.BlogTypeMapper.listBlogType      : ==> Parameters: 
2021-04-25 19:06:06.363 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.BlogTypeMapper.listBlogType      : <==      Total: 4
2021-04-25 19:06:06.364 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.TagMapper.listTag     : ==>  Preparing: SELECT t.*, bt.blog_id FROM tag t LEFT JOIN blog_tags bt ON t.id = bt.tag_id 
2021-04-25 19:06:06.364 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.TagMapper.listTag     : ==> Parameters: 
2021-04-25 19:06:06.374 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.TagMapper.listTag     : <==      Total: 5
2021-04-25 19:06:06.385 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:06:06.385 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:06:06.395 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:06:06.396 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.updateById   : ==>  Preparing: UPDATE user SET nickname=?, username=?, password=?, qq=?, wechat=?, email=?, province=?, city=?, avatar=?, views=?, create_time=?, update_time=?, user_signature=? WHERE id=? 
2021-04-25 19:06:06.397 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.updateById   : ==> Parameters: lyric(String), lyric(String), 96e79218965eb72c92a549dd5a330112(String), 2044619214(String), 17805428855(String), lyric0926@163.com(String), 浙江(String), 杭州(String), /images/user.jpg(String), 45827(Integer), 2020-09-02 15:16:51.0(Timestamp), 2021-04-02 00:55:48.5(Timestamp), 你生命中最美好的一天，就是你决定让你的人生属于你自己的那一天。(String), 1(Long)
2021-04-25 19:06:06.416 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.updateById   : <==    Updates: 1
2021-04-25 19:06:06.445  INFO 19964 --- [http-nio-8080-exec-7] com.yi.blog.aspect.LogAspect             : Result:index
2021-04-25 19:06:06.722  INFO 19964 --- [http-nio-8080-exec-6] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/footer/newBlog', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.newblogs', args=[{}]}
2021-04-25 19:06:06.722  INFO 19964 --- [http-nio-8080-exec-6] com.yi.blog.aspect.LogAspect             : Result:_fragments :: newBlogList
2021-04-25 19:06:12.229  INFO 19964 --- [http-nio-8080-exec-3] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/archives', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.ArchiveShowController.archives', args=[{}]}
2021-04-25 19:06:12.240 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.m.BlogTypeMapper.listBlogType      : ==>  Preparing: SELECT bt.*, b.id b_id FROM blog_type bt LEFT JOIN blog b ON bt.id = b.blog_type_id 
2021-04-25 19:06:12.240 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.m.BlogTypeMapper.listBlogType      : ==> Parameters: 
2021-04-25 19:06:12.251 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.m.BlogTypeMapper.listBlogType      : <==      Total: 4
2021-04-25 19:06:12.251 DEBUG 19964 --- [http-nio-8080-exec-3] com.yi.blog.mapper.TagMapper.listTag     : ==>  Preparing: SELECT t.*, bt.blog_id FROM tag t LEFT JOIN blog_tags bt ON t.id = bt.tag_id 
2021-04-25 19:06:12.251 DEBUG 19964 --- [http-nio-8080-exec-3] com.yi.blog.mapper.TagMapper.listTag     : ==> Parameters: 
2021-04-25 19:06:12.264 DEBUG 19964 --- [http-nio-8080-exec-3] com.yi.blog.mapper.TagMapper.listTag     : <==      Total: 5
2021-04-25 19:06:12.265 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.mapper.BlogMapper.findGroupYear    : ==>  Preparing: SELECT DATE_FORMAT( b.update_time, '%Y' ) year FROM blog b GROUP BY DATE_FORMAT( b.update_time, '%Y' ) ORDER BY year DESC 
2021-04-25 19:06:12.265 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.mapper.BlogMapper.findGroupYear    : ==> Parameters: 
2021-04-25 19:06:12.276 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.mapper.BlogMapper.findGroupYear    : <==      Total: 1
2021-04-25 19:06:12.277 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.findByYear   : ==>  Preparing: SELECT b.* FROM blog b WHERE DATE_FORMAT( b.update_time, '%Y' ) = ? 
2021-04-25 19:06:12.278 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.findByYear   : ==> Parameters: 2021(String)
2021-04-25 19:06:12.304 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.findByYear   : <==      Total: 4
2021-04-25 19:06:12.304  INFO 19964 --- [http-nio-8080-exec-3] com.yi.blog.aspect.LogAspect             : Result:archives
2021-04-25 19:06:14.032  INFO 19964 --- [http-nio-8080-exec-3] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/blog/35', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.blog', args=[35, {}]}
2021-04-25 19:06:14.043 DEBUG 19964 --- [http-nio-8080-exec-3] com.yi.blog.mapper.UserMapper.selectOne  : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE (id = ?) 
2021-04-25 19:06:14.043 DEBUG 19964 --- [http-nio-8080-exec-3] com.yi.blog.mapper.UserMapper.selectOne  : ==> Parameters: 1(Integer)
2021-04-25 19:06:14.054 DEBUG 19964 --- [http-nio-8080-exec-3] com.yi.blog.mapper.UserMapper.selectOne  : <==      Total: 1
2021-04-25 19:06:14.064 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.selectById   : ==>  Preparing: SELECT id,title,content,first_picture,stamp,views,appreciate,original,comments,published,recommend,create_time,update_time,blog_type_id,user_id FROM blog WHERE id=? 
2021-04-25 19:06:14.064 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.selectById   : ==> Parameters: 35(Long)
2021-04-25 19:06:14.075 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.selectById   : <==      Total: 1
2021-04-25 19:06:14.076 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:06:14.077 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:06:14.086 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:06:14.087 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.updateById   : ==>  Preparing: UPDATE blog SET title=?, content=?, stamp=?, views=?, appreciate=?, original=?, comments=?, published=?, recommend=?, create_time=?, update_time=?, blog_type_id=?, user_id=? WHERE id=? 
2021-04-25 19:06:14.088 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.updateById   : ==> Parameters: Spring(二)(String), # Spring：AOP
#Spring产生一个bean的几个过程：
1、new
2、注入
3、init生命周期初始化方法
4、代理AOP
5、put 单例池
等等后产生bean。
第3步，init时，有三个回调方式，分别是@PostConstruct注解、实现InitializationBean接口的afterPropertiesSet()方法、xml中的init的方式。先后顺序为：@PostConstruct->afterPropertiesSet()->xml中的init
然后就是产生代理对象：如果AOP作用了某个对象，就改变了这个对象，底层是用的proxy，代理的方式。(通过applyBeanPostProcessorsAfterInitialization这个方法中的BeanPostProcessors来完成代理。)
这里就解释了二级缓存的作用：
上边那5步，假如现在创建这么一片代码，如果运行下面这行代码：
```java
getBean(OneService.class).getBean(TwoService.class)
```
按理说，OneService创建完以后，twoService并没有进行第4步，所以应该aop切不到这里，而是在第二步的时候，放入了二级缓存中，就是在此时，放进去的时候，二级缓存会做aop的处理。
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```(String), 原创(String), 21(Integer), true(Boolean), true(Boolean), true(Boolean), true(Boolean), true(Boolean), 2021-04-04 23:42:34.043(Timestamp), 2021-04-05 14:53:28.564(Timestamp), 14(Long), 1(Long), 35(Long)
2021-04-25 19:06:14.108 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.updateById   : <==    Updates: 1
2021-04-25 19:06:14.141  INFO 19964 --- [http-nio-8080-exec-3] com.yi.blog.aspect.LogAspect             : Result:archivedetails
2021-04-25 19:06:15.868  INFO 19964 --- [http-nio-8080-exec-7] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.index', args=[{}, org.apache.catalina.connector.ResponseFacade@592925fb]}
2021-04-25 19:06:15.880 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.B.selectPageByTitleAndType       : ==>  Preparing: SELECT COUNT(1) FROM blog WHERE 1 = 1 
2021-04-25 19:06:15.880 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.B.selectPageByTitleAndType       : ==> Parameters: 
2021-04-25 19:06:15.891 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.B.selectPageByTitleAndType       : ==>  Preparing: SELECT * FROM blog WHERE 1 = 1 ORDER BY update_time DESC LIMIT ?,? 
2021-04-25 19:06:15.891 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.B.selectPageByTitleAndType       : ==> Parameters: 0(Long), 8(Long)
2021-04-25 19:06:15.917 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.mapper.BlogTypeMapper.getBlogType  : ====>  Preparing: select * from blog_type where id = ? 
2021-04-25 19:06:15.917 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.mapper.BlogTypeMapper.getBlogType  : ====> Parameters: 14(Long)
2021-04-25 19:06:15.928 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.mapper.BlogTypeMapper.getBlogType  : <====      Total: 1
2021-04-25 19:06:15.929 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.B.selectPageByTitleAndType       : <==      Total: 4
2021-04-25 19:06:15.930 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.BlogTypeMapper.listBlogType      : ==>  Preparing: SELECT bt.*, b.id b_id FROM blog_type bt LEFT JOIN blog b ON bt.id = b.blog_type_id 
2021-04-25 19:06:15.930 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.BlogTypeMapper.listBlogType      : ==> Parameters: 
2021-04-25 19:06:15.941 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.BlogTypeMapper.listBlogType      : <==      Total: 4
2021-04-25 19:06:15.942 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.TagMapper.listTag     : ==>  Preparing: SELECT t.*, bt.blog_id FROM tag t LEFT JOIN blog_tags bt ON t.id = bt.tag_id 
2021-04-25 19:06:15.942 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.TagMapper.listTag     : ==> Parameters: 
2021-04-25 19:06:15.952 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.TagMapper.listTag     : <==      Total: 5
2021-04-25 19:06:15.962 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:06:15.963 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:06:15.973 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:06:15.974 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.updateById   : ==>  Preparing: UPDATE user SET nickname=?, username=?, password=?, qq=?, wechat=?, email=?, province=?, city=?, avatar=?, views=?, create_time=?, update_time=?, user_signature=? WHERE id=? 
2021-04-25 19:06:15.975 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.updateById   : ==> Parameters: lyric(String), lyric(String), 96e79218965eb72c92a549dd5a330112(String), 2044619214(String), 17805428855(String), lyric0926@163.com(String), 浙江(String), 杭州(String), /images/user.jpg(String), 45828(Integer), 2020-09-02 15:16:51.0(Timestamp), 2021-04-02 00:55:48.5(Timestamp), 你生命中最美好的一天，就是你决定让你的人生属于你自己的那一天。(String), 1(Long)
2021-04-25 19:06:15.994 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.updateById   : <==    Updates: 1
2021-04-25 19:06:16.023  INFO 19964 --- [http-nio-8080-exec-7] com.yi.blog.aspect.LogAspect             : Result:index
2021-04-25 19:06:16.274  INFO 19964 --- [http-nio-8080-exec-8] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/footer/newBlog', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.newblogs', args=[{}]}
2021-04-25 19:06:16.274  INFO 19964 --- [http-nio-8080-exec-8] com.yi.blog.aspect.LogAspect             : Result:_fragments :: newBlogList
2021-04-25 19:06:17.337  INFO 19964 --- [http-nio-8080-exec-2] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/blog/34', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.blog', args=[34, {}]}
2021-04-25 19:06:17.349 DEBUG 19964 --- [http-nio-8080-exec-2] com.yi.blog.mapper.UserMapper.selectOne  : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE (id = ?) 
2021-04-25 19:06:17.349 DEBUG 19964 --- [http-nio-8080-exec-2] com.yi.blog.mapper.UserMapper.selectOne  : ==> Parameters: 1(Integer)
2021-04-25 19:06:17.360 DEBUG 19964 --- [http-nio-8080-exec-2] com.yi.blog.mapper.UserMapper.selectOne  : <==      Total: 1
2021-04-25 19:06:17.370 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.BlogMapper.selectById   : ==>  Preparing: SELECT id,title,content,first_picture,stamp,views,appreciate,original,comments,published,recommend,create_time,update_time,blog_type_id,user_id FROM blog WHERE id=? 
2021-04-25 19:06:17.370 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.BlogMapper.selectById   : ==> Parameters: 34(Long)
2021-04-25 19:06:17.394 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.BlogMapper.selectById   : <==      Total: 1
2021-04-25 19:06:17.395 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:06:17.395 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:06:17.405 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:06:17.406 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.BlogMapper.updateById   : ==>  Preparing: UPDATE blog SET title=?, content=?, stamp=?, views=?, appreciate=?, original=?, comments=?, published=?, recommend=?, create_time=?, update_time=?, blog_type_id=?, user_id=? WHERE id=? 
2021-04-25 19:06:17.408 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.BlogMapper.updateById   : ==> Parameters: Spring(一)(String), # Spring:循环依赖
## 什么是循环依赖?

```java
@ComponentScan("com.yi")
public class MyConfig {

}
```
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
```java
@Component
public class TwoService {
    @Autowired
    OneService oneService;

    public TwoService() {
        System.out.println("Construct TwoService");
    }

    public void getOneService(){
        System.out.println(oneService);
    }
}
```
```java
public class Test {
    public static void main(String[] args) {
        //初始化Spring容器
        AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);

        ac.getBean(OneService.class).getTwoService();
    }
}
```
这四个代码片段，即展示了Spring当中的循环依赖。
明白循环依赖，首先要明白依赖注入。
# Spring：依赖注入
依赖注入是在Spring容器初始化的时候完成的。这期间有一个过程：以上述代码为例，初始化`AnnotationConfigApplicationContext`容器，首先读取`MyConfig`类，扫描包下的Spring管理的注解的类，然后利用这些类的信息，进行bean的初始化。
初始化bean：1、2、3、4、5、6、...N步,分好多步，接下来，看一下这些具体的步骤。
## Spring bean的初始化
普通类的初始化，简单的来说，就是.java结尾的类，在经过编译后，生成.class字节码文件，然后jvm读取这些文件，将读取的类信息，放置到方法区，等到new的时候，利用这些信息，在堆空间开辟空间，产生一个对象。
而Spring bean的初始化，要经过更繁琐的过程。
### scan:
将扫描到的由Spring管理的类，生成类信息。
### parse：
接下来，Spring底层会解析这些类的信息，将一个一个的类，生成一个一个的`BeanDefinition`接口的实现类。
这些`BeanDefinition`类中，保存的是扫描到的类的信息，信息大致有：beanSocpe，扫描到的类是不是单例的？isLazy，扫描到的类是不是标注了`@Lazy`注解，是不是懒加载？不同的信息，Spring将做不同的策略。
### put map：
接下来，把这些`BeanDefinition`对象，放置到一个map中，map的key即扫描类的类名，value即`BeanDefinition`对象。
### 实例化：
接下来，将遍历这个map，然后实例化。实例化出的对象，依然放到新的map当中(`@Lazy`、原型，等特殊对象，此刻不会实例化。
#### Spring bean的生命周期
```java
public void refresh() throws BeansException, IllegalStateException {
        synchronized(this.startupShutdownMonitor) {
            StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");
            this.prepareRefresh();
            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
            this.prepareBeanFactory(beanFactory);

            try {
                this.postProcessBeanFactory(beanFactory);
                StartupStep beanPostProcess = this.applicationStartup.start("spring.context.beans.post-process");
                this.invokeBeanFactoryPostProcessors(beanFactory);
                this.registerBeanPostProcessors(beanFactory);
                beanPostProcess.end();
                this.initMessageSource();
                this.initApplicationEventMulticaster();
                this.onRefresh();
                this.registerListeners();
                this.finishBeanFactoryInitialization(beanFactory);
                this.finishRefresh();
            } catch (BeansException var10) {
                if (this.logger.isWarnEnabled()) {
                    this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var10);
                }

                this.destroyBeans();
                this.cancelRefresh(var10);
                throw var10;
            } finally {
                this.resetCommonCaches();
                contextRefresh.end();
            }

        }
    }
```
`this.invokeBeanFactoryPostProcessors(beanFactory);`此行完成了Spring bean的扫描，此刻，`BeanDefinition`对象已经全部加载到了map当中。
`this.finishBeanFactoryInitialization(beanFactory);`此行完成了实例化。
bean的生命周期，即在`this.finishBeanFactoryInitialization(beanFactory);`中。
进入此方法：
```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
        if (beanFactory.containsBean("conversionService") && beanFactory.isTypeMatch("conversionService", ConversionService.class)) {
            beanFactory.setConversionService((ConversionService)beanFactory.getBean("conversionService", ConversionService.class));
        }

        if (!beanFactory.hasEmbeddedValueResolver()) {
            beanFactory.addEmbeddedValueResolver((strVal) -> {
                return this.getEnvironment().resolvePlaceholders(strVal);
            });
        }

        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
        String[] var3 = weaverAwareNames;
        int var4 = weaverAwareNames.length;

        for(int var5 = 0; var5 < var4; ++var5) {
            String weaverAwareName = var3[var5];
            this.getBean(weaverAwareName);
        }

        beanFactory.setTempClassLoader((ClassLoader)null);
        beanFactory.freezeConfiguration();
        beanFactory.preInstantiateSingletons();
    }
```
`beanFactory.preInstantiateSingletons();`此行实例化所有的单例，非Lazy的。
进入此方法：
```java
public void preInstantiateSingletons() throws BeansException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Pre-instantiating singletons in " + this);
        }

        List<String> beanNames = new ArrayList(this.beanDefinitionNames);
        Iterator var2 = beanNames.iterator();

        while(true) {
            String beanName;
            Object bean;
            do {
                while(true) {
                    RootBeanDefinition bd;
                    do {
                        do {
                            do {
                                if (!var2.hasNext()) {
                                    var2 = beanNames.iterator();

                                    while(var2.hasNext()) {
                                        beanName = (String)var2.next();
                                        Object singletonInstance = this.getSingleton(beanName);
                                        if (singletonInstance instanceof SmartInitializingSingleton) {
                                            StartupStep smartInitialize = this.getApplicationStartup().start("spring.beans.smart-initialize").tag("beanName", beanName);
                                            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;
                                            if (System.getSecurityManager() != null) {
                                                AccessController.doPrivileged(() -> {
                                                    smartSingleton.afterSingletonsInstantiated();
                                                    return null;
                                                }, this.getAccessControlContext());
                                            } else {
                                                smartSingleton.afterSingletonsInstantiated();
                                            }

                                            smartInitialize.end();
                                        }
                                    }

                                    return;
                                }

                                beanName = (String)var2.next();
                                bd = this.getMergedLocalBeanDefinition(beanName);
                            } while(bd.isAbstract());
                        } while(!bd.isSingleton());
                    } while(bd.isLazyInit());

                    if (this.isFactoryBean(beanName)) {
                        bean = this.getBean("&" + beanName);
                        break;
                    }

                    this.getBean(beanName);
                }
            } while(!(bean instanceof FactoryBean));

            FactoryBean<?> factory = (FactoryBean)bean;
            boolean isEagerInit;
            if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                SmartFactoryBean var10000 = (SmartFactoryBean)factory;
                ((SmartFactoryBean)factory).getClass();
                isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, this.getAccessControlContext());
            } else {
                isEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean)factory).isEagerInit();
            }

            if (isEagerInit) {
                this.getBean(beanName);
            }
        }
    }
```
此方法，在遍历`BeanDefinition`对象，来验证这些`BeanDefinition`对象是不是可以将这些描述的bean实例化，因为有些非单例的bean，接下来不应该实例化的，所以有这么一个校验的过程。
接下来：进入此方法：`this.getBean(beanName);`
最核心的方法：
```java
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
        String beanName = this.transformedBeanName(name);
        Object sharedInstance = this.getSingleton(beanName);
        Object beanInstance;
        if (sharedInstance != null && args == null) {
            if (this.logger.isTraceEnabled()) {
                if (this.isSingletonCurrentlyInCreation(beanName)) {
                    this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
                } else {
                    this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
                }
            }

            beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
        } else {
            if (this.isPrototypeCurrentlyInCreation(beanName)) {
                throw new BeanCurrentlyInCreationException(beanName);
            }

            BeanFactory parentBeanFactory = this.getParentBeanFactory();
            if (parentBeanFactory != null && !this.containsBeanDefinition(beanName)) {
                String nameToLookup = this.originalBeanName(name);
                if (parentBeanFactory instanceof AbstractBeanFactory) {
                    return ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
                }

                if (args != null) {
                    return parentBeanFactory.getBean(nameToLookup, args);
                }

                if (requiredType != null) {
                    return parentBeanFactory.getBean(nameToLookup, requiredType);
                }

                return parentBeanFactory.getBean(nameToLookup);
            }

            if (!typeCheckOnly) {
                this.markBeanAsCreated(beanName);
            }

            StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate").tag("beanName", name);

            try {
                if (requiredType != null) {
                    beanCreation.tag("beanType", requiredType::toString);
                }

                RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);
                this.checkMergedBeanDefinition(mbd, beanName, args);
                String[] dependsOn = mbd.getDependsOn();
                String[] var12;
                if (dependsOn != null) {
                    var12 = dependsOn;
                    int var13 = dependsOn.length;

                    for(int var14 = 0; var14 < var13; ++var14) {
                        String dep = var12[var14];
                        if (this.isDependent(beanName, dep)) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                        }

                        this.registerDependentBean(dep, beanName);

                        try {
                            this.getBean(dep);
                        } catch (NoSuchBeanDefinitionException var31) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "'" + beanName + "' depends on missing bean '" + dep + "'", var31);
                        }
                    }
                }

                if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                } else if (mbd.isPrototype()) {
                    var12 = null;

                    Object prototypeInstance;
                    try {
                        this.beforePrototypeCreation(beanName);
                        prototypeInstance = this.createBean(beanName, mbd, args);
                    } finally {
                        this.afterPrototypeCreation(beanName);
                    }

                    beanInstance = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                } else {
                    String scopeName = mbd.getScope();
                    if (!StringUtils.hasLength(scopeName)) {
                        throw new IllegalStateException("No scope name defined for bean ��" + beanName + "'");
                    }

                    Scope scope = (Scope)this.scopes.get(scopeName);
                    if (scope == null) {
                        throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                    }

                    try {
                        Object scopedInstance = scope.get(beanName, () -> {
                            this.beforePrototypeCreation(beanName);

                            Object var4;
                            try {
                                var4 = this.createBean(beanName, mbd, args);
                            } finally {
                                this.afterPrototypeCreation(beanName);
                            }

                            return var4;
                        });
                        beanInstance = this.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                    } catch (IllegalStateException var30) {
                        throw new ScopeNotActiveException(beanName, scopeName, var30);
                    }
                }
            } catch (BeansException var32) {
                beanCreation.tag("exception", var32.getClass().toString());
                beanCreation.tag("message", String.valueOf(var32.getMessage()));
                this.cleanupAfterBeanCreationFailure(beanName);
                throw var32;
            } finally {
                beanCreation.end();
            }
        }

        return this.adaptBeanInstance(name, beanInstance, requiredType);
    }
```
`String beanName = this.transformedBeanName(name);`此行，先认为它是校验bean的名字是不是合法，其实还有很多其他作用；
`Object sharedInstance = this.getSingleton(beanName);`此行，是从一个map中尝试拿一下，这个bean，这个map是一个ConcurrentHashMap，是常说的Spring容器，但准确的应该叫Spring单例池，但此刻肯定是拿不到的，它为什么要拿一下呢?这里有个很关键的方法：`isSingletonCurrentlyInCreation(beanName)`
```java
String beanName = this.transformedBeanName(name);
Object sharedInstance = this.getSingleton(beanName);
Object beanInstance;
if (sharedInstance != null && args == null) {
    if (this.logger.isTraceEnabled()) {
        if (this.isSingletonCurrentlyInCreation(beanName)) {
            this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
        } else {
            this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
        }
    }

    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
}
```
至此，先跳过这部分。
再回到doGetBean方法：来到：
```java
if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }
```
此处，就要进行创建对象了：
```java
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Creating instance of bean '" + beanName + "'");
        }

        RootBeanDefinition mbdToUse = mbd;
        Class<?> resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
        if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
            mbdToUse = new RootBeanDefinition(mbd);
            mbdToUse.setBeanClass(resolvedClass);
        }

        try {
            mbdToUse.prepareMethodOverrides();
        } catch (BeanDefinitionValidationException var9) {
            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", var9);
        }

        Object beanInstance;
        try {
            beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);
            if (beanInstance != null) {
                return beanInstance;
            }
        } catch (Throwable var10) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", var10);
        }

        try {
            beanInstance = this.doCreateBean(beanName, mbdToUse, args);
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Finished creating instance of bean '" + beanName + "'");
            }

            return beanInstance;
        } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) {
            throw var7;
        } catch (Throwable var8) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", var8);
        }
    }
```
上面这段代码，可以看到，就是通过`BeanDefinition`对象拿到bean的Class类的对象出来，准备创建对象，就是拿到该类的构造器等信息，来实例化。虽然是实例化了，但并不是完整的Spring bean。如下代码片段
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    @PostConstruct
    public void aa(){
        //Spring bean生命周期初始化回调方法
        System.out.println("init");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
它这一步，仅仅是创建了OneService的基本对象，@Autowired，还有AOP功能，@PostConstruct等等都没有做，仅仅是new出来了这个基本对象。
在创建的过程中，进入doCreateBean方法中：
```java
//判断是否允许循环依赖
//主要就是this.allowCircularReferences,而Spring关闭默认允许循环依赖的关键也就是这里
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }

    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}
```
## 问题：怎么关闭Spring默认的允许循环依赖
1、直接修改源码，赋值allowCircularReferences属性为false。
2、手动refresh：
```java
//1、初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext(MyConfig.class);
//2、拿到beanFactory
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
//但这样其实没有用,因为1、步已经完成了容器的初始化。
```
正确的做法：
```java
//初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext();
//先调用默认构造器，然后自己来实现其构造器中的两个关键方法：register和refresh
ac.register(MyConfig.class);
//在此关闭循环依赖
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
ac.refresh();
```
回到创建过程：
```java
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }
    //在此进行第四次后置处理器，判断是否需要AOP
    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}

Object exposedObject = bean;

try {
    //填充属性，也就是常常说的自动注入
    //里面会完成第五次和第六次后置处理器的调用
    this.populateBean(beanName, mbd, instanceWrapper);
    //初始化bean
    //里面会完成第七次和第八次后置处理器的调用
    exposedObject = this.initializeBean(beanName, exposedObject, mbd);
} catch (Throwable var18) {
    if (var18 instanceof BeanCreationException && beanName.equals(((BeanCreationException)var18).getBeanName())) {
        throw (BeanCreationException)var18;
    }

    throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", var18);
}
```
进入populateBean方法：
```java
if (hasInstAwareBpps) {
    if (pvs == null) {
        pvs = mbd.getPropertyValues();
    }

    PropertyValues pvsToUse;
    for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {
        InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();
        pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
        if (pvsToUse == null) {
            if (filteredPds == null) {
                filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            }

            pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
                return;
            }
        }
    }
}
```
此行：`pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);`完成后，完成注入，比如TwoService，这时候就注入了进来。
注意，此处是个for循环，该循环在遍历后置处理器BeanPostProcessors，然后不同的BeanPostProcessor作不同的事情，比如常说的@Autowired注解，和@Resource注解的区别，这两个注解的组件走到这里的时候，会有不同的后置处理器来处理。
至此，来看开始循环注入的问题：
首先:初始化容器
```java
AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);
```
调用refresh方法：
```java
this.refresh();
```
经过：
```java
this.invokeBeanFactoryPostProcessors(beanFactory);
```
后完成扫描。
经过：
```java
this.finishBeanFactoryInitialization(beanFactory);
```
后完成bean的初始化。在：`this.finishBeanFactoryInitialization(beanFactory);`中，又进行了实例化所有的单例，非Lazy的bean：
```java
beanFactory.preInstantiateSingletons();
```
这里面，创建对象的过程是，先new出了基本的对象，然后接着进行属性填充：
```java
this.populateBean(beanName, mbd, instanceWrapper);
```
就是在此时，填充TwoService，这时候他会从容器中去拿TwoService这个bean，就是单例池中去拿，这时候肯定拿不到。
这时候就到了上面提到的：去池子中拿，拿不到，这时候有一个很关键的判断：
`if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName))`
```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
这个判断条件是不成立的。如果该条件成立，那么就要去三级缓存中拿。
# 循环依赖类的创建流程总结：
OK，循环依赖的两个类加载的过程：
调用构造方法new出OneService对象-->如果是单例，还会把自己放到一个代表正在创建中的Set集合中，如果开启了循环依赖，就会把当前的OneService的对象放到二级缓存中-->继续走，走到populateBean要进行填充TwoService-->从容器中找，这时候找不到。此刻就有上边这个判断，是不是正在创建的bean，如果此判断成功进入，就会从三级缓存中拿出来。-->拿不到，条件也没成立，这时候，就要new出TwoService来，当然此时new出的来TwoServcie对象，也要走bean的生命周期，那么它最终还是会走到populateBean这个方法，它也会去填充属性--->从容器中找OneService的bean，拿不到，所以它又要实例化一遍OneService，但这个过程中，但是此时有个判断条件却成立了，因为OneService确实是正在创建中，它从二级缓存中拿，是能拿到的，之前的过程存进去了。这时候，拿到OneService的对象，不等于null，就给TwoService注入了。
```java
/**
 * 比如第一次加载OneService,就会把自己放入二级缓存，当OneService进行到populateBean时，就会准备注入TwoService，
 * TwoService，也一样，最后进行到populateBean，从单例池中拿OneService，拿不到，继续从三级中拿，拿不到，继续从
 * 二级中拿，拿到了，就把OneService放进三级缓存，并将二级缓存中的移除。 
 */
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    //一级缓存：即单例池
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        //从三级缓存中拿 
        singletonObject = this.earlySingletonObjects.get(beanName);
        //如果拿不到
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        //从二级缓存中拿
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        //如果拿到了 
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            //放入三级缓存中
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            //将二级缓存中的移除
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
(String), 原创(String), 161(Integer), true(Boolean), true(Boolean), true(Boolean), true(Boolean), true(Boolean), 2021-04-03 01:26:55.386(Timestamp), 2021-04-04 23:40:56.51(Timestamp), 14(Long), 1(Long), 34(Long)
2021-04-25 19:06:17.443 DEBUG 19964 --- [http-nio-8080-exec-2] c.yi.blog.mapper.BlogMapper.updateById   : <==    Updates: 1
2021-04-25 19:06:17.479  INFO 19964 --- [http-nio-8080-exec-2] com.yi.blog.aspect.LogAspect             : Result:archivedetails
2021-04-25 19:07:28.090  INFO 19964 --- [http-nio-8080-exec-7] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/blog/34', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.blog', args=[34, {}]}
2021-04-25 19:07:28.101 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.UserMapper.selectOne  : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE (id = ?) 
2021-04-25 19:07:28.102 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.UserMapper.selectOne  : ==> Parameters: 1(Integer)
2021-04-25 19:07:28.113 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.UserMapper.selectOne  : <==      Total: 1
2021-04-25 19:07:28.124 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.BlogMapper.selectById   : ==>  Preparing: SELECT id,title,content,first_picture,stamp,views,appreciate,original,comments,published,recommend,create_time,update_time,blog_type_id,user_id FROM blog WHERE id=? 
2021-04-25 19:07:28.124 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.BlogMapper.selectById   : ==> Parameters: 34(Long)
2021-04-25 19:07:28.149 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.BlogMapper.selectById   : <==      Total: 1
2021-04-25 19:07:28.151 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:07:28.152 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:07:28.163 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:07:28.164 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.BlogMapper.updateById   : ==>  Preparing: UPDATE blog SET title=?, content=?, stamp=?, views=?, appreciate=?, original=?, comments=?, published=?, recommend=?, create_time=?, update_time=?, blog_type_id=?, user_id=? WHERE id=? 
2021-04-25 19:07:28.167 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.BlogMapper.updateById   : ==> Parameters: Spring(一)(String), # Spring:循环依赖
## 什么是循环依赖?

```java
@ComponentScan("com.yi")
public class MyConfig {

}
```
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
```java
@Component
public class TwoService {
    @Autowired
    OneService oneService;

    public TwoService() {
        System.out.println("Construct TwoService");
    }

    public void getOneService(){
        System.out.println(oneService);
    }
}
```
```java
public class Test {
    public static void main(String[] args) {
        //初始化Spring容器
        AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);

        ac.getBean(OneService.class).getTwoService();
    }
}
```
这四个代码片段，即展示了Spring当中的循环依赖。
明白循环依赖，首先要明白依赖注入。
# Spring：依赖注入
依赖注入是在Spring容器初始化的时候完成的。这期间有一个过程：以上述代码为例，初始化`AnnotationConfigApplicationContext`容器，首先读取`MyConfig`类，扫描包下的Spring管理的注解的类，然后利用这些类的信息，进行bean的初始化。
初始化bean：1、2、3、4、5、6、...N步,分好多步，接下来，看一下这些具体的步骤。
## Spring bean的初始化
普通类的初始化，简单的来说，就是.java结尾的类，在经过编译后，生成.class字节码文件，然后jvm读取这些文件，将读取的类信息，放置到方法区，等到new的时候，利用这些信息，在堆空间开辟空间，产生一个对象。
而Spring bean的初始化，要经过更繁琐的过程。
### scan:
将扫描到的由Spring管理的类，生成类信息。
### parse：
接下来，Spring底层会解析这些类的信息，将一个一个的类，生成一个一个的`BeanDefinition`接口的实现类。
这些`BeanDefinition`类中，保存的是扫描到的类的信息，信息大致有：beanSocpe，扫描到的类是不是单例的？isLazy，扫描到的类是不是标注了`@Lazy`注解，是不是懒加载？不同的信息，Spring将做不同的策略。
### put map：
接下来，把这些`BeanDefinition`对象，放置到一个map中，map的key即扫描类的类名，value即`BeanDefinition`对象。
### 实例化：
接下来，将遍历这个map，然后实例化。实例化出的对象，依然放到新的map当中(`@Lazy`、原型，等特殊对象，此刻不会实例化。
#### Spring bean的生命周期
```java
public void refresh() throws BeansException, IllegalStateException {
        synchronized(this.startupShutdownMonitor) {
            StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");
            this.prepareRefresh();
            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
            this.prepareBeanFactory(beanFactory);

            try {
                this.postProcessBeanFactory(beanFactory);
                StartupStep beanPostProcess = this.applicationStartup.start("spring.context.beans.post-process");
                this.invokeBeanFactoryPostProcessors(beanFactory);
                this.registerBeanPostProcessors(beanFactory);
                beanPostProcess.end();
                this.initMessageSource();
                this.initApplicationEventMulticaster();
                this.onRefresh();
                this.registerListeners();
                this.finishBeanFactoryInitialization(beanFactory);
                this.finishRefresh();
            } catch (BeansException var10) {
                if (this.logger.isWarnEnabled()) {
                    this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var10);
                }

                this.destroyBeans();
                this.cancelRefresh(var10);
                throw var10;
            } finally {
                this.resetCommonCaches();
                contextRefresh.end();
            }

        }
    }
```
`this.invokeBeanFactoryPostProcessors(beanFactory);`此行完成了Spring bean的扫描，此刻，`BeanDefinition`对象已经全部加载到了map当中。
`this.finishBeanFactoryInitialization(beanFactory);`此行完成了实例化。
bean的生命周期，即在`this.finishBeanFactoryInitialization(beanFactory);`中。
进入此方法：
```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
        if (beanFactory.containsBean("conversionService") && beanFactory.isTypeMatch("conversionService", ConversionService.class)) {
            beanFactory.setConversionService((ConversionService)beanFactory.getBean("conversionService", ConversionService.class));
        }

        if (!beanFactory.hasEmbeddedValueResolver()) {
            beanFactory.addEmbeddedValueResolver((strVal) -> {
                return this.getEnvironment().resolvePlaceholders(strVal);
            });
        }

        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
        String[] var3 = weaverAwareNames;
        int var4 = weaverAwareNames.length;

        for(int var5 = 0; var5 < var4; ++var5) {
            String weaverAwareName = var3[var5];
            this.getBean(weaverAwareName);
        }

        beanFactory.setTempClassLoader((ClassLoader)null);
        beanFactory.freezeConfiguration();
        beanFactory.preInstantiateSingletons();
    }
```
`beanFactory.preInstantiateSingletons();`此行实例化所有的单例，非Lazy的。
进入此方法：
```java
public void preInstantiateSingletons() throws BeansException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Pre-instantiating singletons in " + this);
        }

        List<String> beanNames = new ArrayList(this.beanDefinitionNames);
        Iterator var2 = beanNames.iterator();

        while(true) {
            String beanName;
            Object bean;
            do {
                while(true) {
                    RootBeanDefinition bd;
                    do {
                        do {
                            do {
                                if (!var2.hasNext()) {
                                    var2 = beanNames.iterator();

                                    while(var2.hasNext()) {
                                        beanName = (String)var2.next();
                                        Object singletonInstance = this.getSingleton(beanName);
                                        if (singletonInstance instanceof SmartInitializingSingleton) {
                                            StartupStep smartInitialize = this.getApplicationStartup().start("spring.beans.smart-initialize").tag("beanName", beanName);
                                            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;
                                            if (System.getSecurityManager() != null) {
                                                AccessController.doPrivileged(() -> {
                                                    smartSingleton.afterSingletonsInstantiated();
                                                    return null;
                                                }, this.getAccessControlContext());
                                            } else {
                                                smartSingleton.afterSingletonsInstantiated();
                                            }

                                            smartInitialize.end();
                                        }
                                    }

                                    return;
                                }

                                beanName = (String)var2.next();
                                bd = this.getMergedLocalBeanDefinition(beanName);
                            } while(bd.isAbstract());
                        } while(!bd.isSingleton());
                    } while(bd.isLazyInit());

                    if (this.isFactoryBean(beanName)) {
                        bean = this.getBean("&" + beanName);
                        break;
                    }

                    this.getBean(beanName);
                }
            } while(!(bean instanceof FactoryBean));

            FactoryBean<?> factory = (FactoryBean)bean;
            boolean isEagerInit;
            if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                SmartFactoryBean var10000 = (SmartFactoryBean)factory;
                ((SmartFactoryBean)factory).getClass();
                isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, this.getAccessControlContext());
            } else {
                isEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean)factory).isEagerInit();
            }

            if (isEagerInit) {
                this.getBean(beanName);
            }
        }
    }
```
此方法，在遍历`BeanDefinition`对象，来验证这些`BeanDefinition`对象是不是可以将这些描述的bean实例化，因为有些非单例的bean，接下来不应该实例化的，所以有这么一个校验的过程。
接下来：进入此方法：`this.getBean(beanName);`
最核心的方法：
```java
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
        String beanName = this.transformedBeanName(name);
        Object sharedInstance = this.getSingleton(beanName);
        Object beanInstance;
        if (sharedInstance != null && args == null) {
            if (this.logger.isTraceEnabled()) {
                if (this.isSingletonCurrentlyInCreation(beanName)) {
                    this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
                } else {
                    this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
                }
            }

            beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
        } else {
            if (this.isPrototypeCurrentlyInCreation(beanName)) {
                throw new BeanCurrentlyInCreationException(beanName);
            }

            BeanFactory parentBeanFactory = this.getParentBeanFactory();
            if (parentBeanFactory != null && !this.containsBeanDefinition(beanName)) {
                String nameToLookup = this.originalBeanName(name);
                if (parentBeanFactory instanceof AbstractBeanFactory) {
                    return ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
                }

                if (args != null) {
                    return parentBeanFactory.getBean(nameToLookup, args);
                }

                if (requiredType != null) {
                    return parentBeanFactory.getBean(nameToLookup, requiredType);
                }

                return parentBeanFactory.getBean(nameToLookup);
            }

            if (!typeCheckOnly) {
                this.markBeanAsCreated(beanName);
            }

            StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate").tag("beanName", name);

            try {
                if (requiredType != null) {
                    beanCreation.tag("beanType", requiredType::toString);
                }

                RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);
                this.checkMergedBeanDefinition(mbd, beanName, args);
                String[] dependsOn = mbd.getDependsOn();
                String[] var12;
                if (dependsOn != null) {
                    var12 = dependsOn;
                    int var13 = dependsOn.length;

                    for(int var14 = 0; var14 < var13; ++var14) {
                        String dep = var12[var14];
                        if (this.isDependent(beanName, dep)) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                        }

                        this.registerDependentBean(dep, beanName);

                        try {
                            this.getBean(dep);
                        } catch (NoSuchBeanDefinitionException var31) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "'" + beanName + "' depends on missing bean '" + dep + "'", var31);
                        }
                    }
                }

                if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                } else if (mbd.isPrototype()) {
                    var12 = null;

                    Object prototypeInstance;
                    try {
                        this.beforePrototypeCreation(beanName);
                        prototypeInstance = this.createBean(beanName, mbd, args);
                    } finally {
                        this.afterPrototypeCreation(beanName);
                    }

                    beanInstance = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                } else {
                    String scopeName = mbd.getScope();
                    if (!StringUtils.hasLength(scopeName)) {
                        throw new IllegalStateException("No scope name defined for bean ��" + beanName + "'");
                    }

                    Scope scope = (Scope)this.scopes.get(scopeName);
                    if (scope == null) {
                        throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                    }

                    try {
                        Object scopedInstance = scope.get(beanName, () -> {
                            this.beforePrototypeCreation(beanName);

                            Object var4;
                            try {
                                var4 = this.createBean(beanName, mbd, args);
                            } finally {
                                this.afterPrototypeCreation(beanName);
                            }

                            return var4;
                        });
                        beanInstance = this.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                    } catch (IllegalStateException var30) {
                        throw new ScopeNotActiveException(beanName, scopeName, var30);
                    }
                }
            } catch (BeansException var32) {
                beanCreation.tag("exception", var32.getClass().toString());
                beanCreation.tag("message", String.valueOf(var32.getMessage()));
                this.cleanupAfterBeanCreationFailure(beanName);
                throw var32;
            } finally {
                beanCreation.end();
            }
        }

        return this.adaptBeanInstance(name, beanInstance, requiredType);
    }
```
`String beanName = this.transformedBeanName(name);`此行，先认为它是校验bean的名字是不是合法，其实还有很多其他作用；
`Object sharedInstance = this.getSingleton(beanName);`此行，是从一个map中尝试拿一下，这个bean，这个map是一个ConcurrentHashMap，是常说的Spring容器，但准确的应该叫Spring单例池，但此刻肯定是拿不到的，它为什么要拿一下呢?这里有个很关键的方法：`isSingletonCurrentlyInCreation(beanName)`
```java
String beanName = this.transformedBeanName(name);
Object sharedInstance = this.getSingleton(beanName);
Object beanInstance;
if (sharedInstance != null && args == null) {
    if (this.logger.isTraceEnabled()) {
        if (this.isSingletonCurrentlyInCreation(beanName)) {
            this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
        } else {
            this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
        }
    }

    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
}
```
至此，先跳过这部分。
再回到doGetBean方法：来到：
```java
if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }
```
此处，就要进行创建对象了：
```java
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Creating instance of bean '" + beanName + "'");
        }

        RootBeanDefinition mbdToUse = mbd;
        Class<?> resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
        if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
            mbdToUse = new RootBeanDefinition(mbd);
            mbdToUse.setBeanClass(resolvedClass);
        }

        try {
            mbdToUse.prepareMethodOverrides();
        } catch (BeanDefinitionValidationException var9) {
            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", var9);
        }

        Object beanInstance;
        try {
            beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);
            if (beanInstance != null) {
                return beanInstance;
            }
        } catch (Throwable var10) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", var10);
        }

        try {
            beanInstance = this.doCreateBean(beanName, mbdToUse, args);
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Finished creating instance of bean '" + beanName + "'");
            }

            return beanInstance;
        } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) {
            throw var7;
        } catch (Throwable var8) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", var8);
        }
    }
```
上面这段代码，可以看到，就是通过`BeanDefinition`对象拿到bean的Class类的对象出来，准备创建对象，就是拿到该类的构造器等信息，来实例化。虽然是实例化了，但并不是完整的Spring bean。如下代码片段
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    @PostConstruct
    public void aa(){
        //Spring bean生命周期初始化回调方法
        System.out.println("init");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
它这一步，仅仅是创建了OneService的基本对象，@Autowired，还有AOP功能，@PostConstruct等等都没有做，仅仅是new出来了这个基本对象。
在创建的过程中，进入doCreateBean方法中：
```java
//判断是否允许循环依赖
//主要就是this.allowCircularReferences,而Spring关闭默认允许循环依赖的关键也就是这里
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }

    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}
```
## 问题：怎么关闭Spring默认的允许循环依赖
1、直接修改源码，赋值allowCircularReferences属性为false。
2、手动refresh：
```java
//1、初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext(MyConfig.class);
//2、拿到beanFactory
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
//但这样其实没有用,因为1、步已经完成了容器的初始化。
```
正确的做法：
```java
//初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext();
//先调用默认构造器，然后自己来实现其构造器中的两个关键方法：register和refresh
ac.register(MyConfig.class);
//在此关闭循环依赖
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
ac.refresh();
```
回到创建过程：
```java
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }
    //在此进行第四次后置处理器，判断是否需要AOP
    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}

Object exposedObject = bean;

try {
    //填充属性，也就是常常说的自动注入
    //里面会完成第五次和第六次后置处理器的调用
    this.populateBean(beanName, mbd, instanceWrapper);
    //初始化bean
    //里面会完成第七次和第八次后置处理器的调用
    exposedObject = this.initializeBean(beanName, exposedObject, mbd);
} catch (Throwable var18) {
    if (var18 instanceof BeanCreationException && beanName.equals(((BeanCreationException)var18).getBeanName())) {
        throw (BeanCreationException)var18;
    }

    throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", var18);
}
```
进入populateBean方法：
```java
if (hasInstAwareBpps) {
    if (pvs == null) {
        pvs = mbd.getPropertyValues();
    }

    PropertyValues pvsToUse;
    for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {
        InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();
        pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
        if (pvsToUse == null) {
            if (filteredPds == null) {
                filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            }

            pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
                return;
            }
        }
    }
}
```
此行：`pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);`完成后，完成注入，比如TwoService，这时候就注入了进来。
注意，此处是个for循环，该循环在遍历后置处理器BeanPostProcessors，然后不同的BeanPostProcessor作不同的事情，比如常说的@Autowired注解，和@Resource注解的区别，这两个注解的组件走到这里的时候，会有不同的后置处理器来处理。
至此，来看开始循环注入的问题：
首先:初始化容器
```java
AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);
```
调用refresh方法：
```java
this.refresh();
```
经过：
```java
this.invokeBeanFactoryPostProcessors(beanFactory);
```
后完成扫描。
经过：
```java
this.finishBeanFactoryInitialization(beanFactory);
```
后完成bean的初始化。在：`this.finishBeanFactoryInitialization(beanFactory);`中，又进行了实例化所有的单例，非Lazy的bean：
```java
beanFactory.preInstantiateSingletons();
```
这里面，创建对象的过程是，先new出了基本的对象，然后接着进行属性填充：
```java
this.populateBean(beanName, mbd, instanceWrapper);
```
就是在此时，填充TwoService，这时候他会从容器中去拿TwoService这个bean，就是单例池中去拿，这时候肯定拿不到。
这时候就到了上面提到的：去池子中拿，拿不到，这时候有一个很关键的判断：
`if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName))`
```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
这个判断条件是不成立的。如果该条件成立，那么就要去三级缓存中拿。
# 循环依赖类的创建流程总结：
OK，循环依赖的两个类加载的过程：
调用构造方法new出OneService对象-->如果是单例，还会把自己放到一个代表正在创建中的Set集合中，如果开启了循环依赖，就会把当前的OneService的对象放到二级缓存中-->继续走，走到populateBean要进行填充TwoService-->从容器中找，这时候找不到。此刻就有上边这个判断，是不是正在创建的bean，如果此判断成功进入，就会从三级缓存中拿出来。-->拿不到，条件也没成立，这时候，就要new出TwoService来，当然此时new出的来TwoServcie对象，也要走bean的生命周期，那么它最终还是会走到populateBean这个方法，它也会去填充属性--->从容器中找OneService的bean，拿不到，所以它又要实例化一遍OneService，但这个过程中，但是此时有个判断条件却成立了，因为OneService确实是正在创建中，它从二级缓存中拿，是能拿到的，之前的过程存进去了。这时候，拿到OneService的对象，不等于null，就给TwoService注入了。
```java
/**
 * 比如第一次加载OneService,就会把自己放入二级缓存，当OneService进行到populateBean时，就会准备注入TwoService，
 * TwoService，也一样，最后进行到populateBean，从单例池中拿OneService，拿不到，继续从三级中拿，拿不到，继续从
 * 二级中拿，拿到了，就把OneService放进三级缓存，并将二级缓存中的移除。 
 */
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    //一级缓存：即单例池
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        //从三级缓存中拿 
        singletonObject = this.earlySingletonObjects.get(beanName);
        //如果拿不到
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        //从二级缓存中拿
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        //如果拿到了 
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            //放入三级缓存中
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            //将二级缓存中的移除
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
(String), 原创(String), 162(Integer), true(Boolean), true(Boolean), true(Boolean), true(Boolean), true(Boolean), 2021-04-03 01:26:55.386(Timestamp), 2021-04-04 23:40:56.51(Timestamp), 14(Long), 1(Long), 34(Long)
2021-04-25 19:07:28.192 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.BlogMapper.updateById   : <==    Updates: 1
2021-04-25 19:07:28.226  INFO 19964 --- [http-nio-8080-exec-7] com.yi.blog.aspect.LogAspect             : Result:archivedetails
2021-04-25 19:07:44.581  INFO 19964 --- [http-nio-8080-exec-10] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/blog/34', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.blog', args=[34, {}]}
2021-04-25 19:07:44.591 DEBUG 19964 --- [http-nio-8080-exec-10] com.yi.blog.mapper.UserMapper.selectOne  : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE (id = ?) 
2021-04-25 19:07:44.592 DEBUG 19964 --- [http-nio-8080-exec-10] com.yi.blog.mapper.UserMapper.selectOne  : ==> Parameters: 1(Integer)
2021-04-25 19:07:44.602 DEBUG 19964 --- [http-nio-8080-exec-10] com.yi.blog.mapper.UserMapper.selectOne  : <==      Total: 1
2021-04-25 19:07:44.612 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.BlogMapper.selectById   : ==>  Preparing: SELECT id,title,content,first_picture,stamp,views,appreciate,original,comments,published,recommend,create_time,update_time,blog_type_id,user_id FROM blog WHERE id=? 
2021-04-25 19:07:44.613 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.BlogMapper.selectById   : ==> Parameters: 34(Long)
2021-04-25 19:07:44.637 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.BlogMapper.selectById   : <==      Total: 1
2021-04-25 19:07:44.638 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:07:44.638 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:07:44.649 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:07:44.650 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.BlogMapper.updateById   : ==>  Preparing: UPDATE blog SET title=?, content=?, stamp=?, views=?, appreciate=?, original=?, comments=?, published=?, recommend=?, create_time=?, update_time=?, blog_type_id=?, user_id=? WHERE id=? 
2021-04-25 19:07:44.652 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.BlogMapper.updateById   : ==> Parameters: Spring(一)(String), # Spring:循环依赖
## 什么是循环依赖?

```java
@ComponentScan("com.yi")
public class MyConfig {

}
```
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
```java
@Component
public class TwoService {
    @Autowired
    OneService oneService;

    public TwoService() {
        System.out.println("Construct TwoService");
    }

    public void getOneService(){
        System.out.println(oneService);
    }
}
```
```java
public class Test {
    public static void main(String[] args) {
        //初始化Spring容器
        AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);

        ac.getBean(OneService.class).getTwoService();
    }
}
```
这四个代码片段，即展示了Spring当中的循环依赖。
明白循环依赖，首先要明白依赖注入。
# Spring：依赖注入
依赖注入是在Spring容器初始化的时候完成的。这期间有一个过程：以上述代码为例，初始化`AnnotationConfigApplicationContext`容器，首先读取`MyConfig`类，扫描包下的Spring管理的注解的类，然后利用这些类的信息，进行bean的初始化。
初始化bean：1、2、3、4、5、6、...N步,分好多步，接下来，看一下这些具体的步骤。
## Spring bean的初始化
普通类的初始化，简单的来说，就是.java结尾的类，在经过编译后，生成.class字节码文件，然后jvm读取这些文件，将读取的类信息，放置到方法区，等到new的时候，利用这些信息，在堆空间开辟空间，产生一个对象。
而Spring bean的初始化，要经过更繁琐的过程。
### scan:
将扫描到的由Spring管理的类，生成类信息。
### parse：
接下来，Spring底层会解析这些类的信息，将一个一个的类，生成一个一个的`BeanDefinition`接口的实现类。
这些`BeanDefinition`类中，保存的是扫描到的类的信息，信息大致有：beanSocpe，扫描到的类是不是单例的？isLazy，扫描到的类是不是标注了`@Lazy`注解，是不是懒加载？不同的信息，Spring将做不同的策略。
### put map：
接下来，把这些`BeanDefinition`对象，放置到一个map中，map的key即扫描类的类名，value即`BeanDefinition`对象。
### 实例化：
接下来，将遍历这个map，然后实例化。实例化出的对象，依然放到新的map当中(`@Lazy`、原型，等特殊对象，此刻不会实例化。
#### Spring bean的生命周期
```java
public void refresh() throws BeansException, IllegalStateException {
        synchronized(this.startupShutdownMonitor) {
            StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");
            this.prepareRefresh();
            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
            this.prepareBeanFactory(beanFactory);

            try {
                this.postProcessBeanFactory(beanFactory);
                StartupStep beanPostProcess = this.applicationStartup.start("spring.context.beans.post-process");
                this.invokeBeanFactoryPostProcessors(beanFactory);
                this.registerBeanPostProcessors(beanFactory);
                beanPostProcess.end();
                this.initMessageSource();
                this.initApplicationEventMulticaster();
                this.onRefresh();
                this.registerListeners();
                this.finishBeanFactoryInitialization(beanFactory);
                this.finishRefresh();
            } catch (BeansException var10) {
                if (this.logger.isWarnEnabled()) {
                    this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var10);
                }

                this.destroyBeans();
                this.cancelRefresh(var10);
                throw var10;
            } finally {
                this.resetCommonCaches();
                contextRefresh.end();
            }

        }
    }
```
`this.invokeBeanFactoryPostProcessors(beanFactory);`此行完成了Spring bean的扫描，此刻，`BeanDefinition`对象已经全部加载到了map当中。
`this.finishBeanFactoryInitialization(beanFactory);`此行完成了实例化。
bean的生命周期，即在`this.finishBeanFactoryInitialization(beanFactory);`中。
进入此方法：
```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
        if (beanFactory.containsBean("conversionService") && beanFactory.isTypeMatch("conversionService", ConversionService.class)) {
            beanFactory.setConversionService((ConversionService)beanFactory.getBean("conversionService", ConversionService.class));
        }

        if (!beanFactory.hasEmbeddedValueResolver()) {
            beanFactory.addEmbeddedValueResolver((strVal) -> {
                return this.getEnvironment().resolvePlaceholders(strVal);
            });
        }

        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
        String[] var3 = weaverAwareNames;
        int var4 = weaverAwareNames.length;

        for(int var5 = 0; var5 < var4; ++var5) {
            String weaverAwareName = var3[var5];
            this.getBean(weaverAwareName);
        }

        beanFactory.setTempClassLoader((ClassLoader)null);
        beanFactory.freezeConfiguration();
        beanFactory.preInstantiateSingletons();
    }
```
`beanFactory.preInstantiateSingletons();`此行实例化所有的单例，非Lazy的。
进入此方法：
```java
public void preInstantiateSingletons() throws BeansException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Pre-instantiating singletons in " + this);
        }

        List<String> beanNames = new ArrayList(this.beanDefinitionNames);
        Iterator var2 = beanNames.iterator();

        while(true) {
            String beanName;
            Object bean;
            do {
                while(true) {
                    RootBeanDefinition bd;
                    do {
                        do {
                            do {
                                if (!var2.hasNext()) {
                                    var2 = beanNames.iterator();

                                    while(var2.hasNext()) {
                                        beanName = (String)var2.next();
                                        Object singletonInstance = this.getSingleton(beanName);
                                        if (singletonInstance instanceof SmartInitializingSingleton) {
                                            StartupStep smartInitialize = this.getApplicationStartup().start("spring.beans.smart-initialize").tag("beanName", beanName);
                                            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;
                                            if (System.getSecurityManager() != null) {
                                                AccessController.doPrivileged(() -> {
                                                    smartSingleton.afterSingletonsInstantiated();
                                                    return null;
                                                }, this.getAccessControlContext());
                                            } else {
                                                smartSingleton.afterSingletonsInstantiated();
                                            }

                                            smartInitialize.end();
                                        }
                                    }

                                    return;
                                }

                                beanName = (String)var2.next();
                                bd = this.getMergedLocalBeanDefinition(beanName);
                            } while(bd.isAbstract());
                        } while(!bd.isSingleton());
                    } while(bd.isLazyInit());

                    if (this.isFactoryBean(beanName)) {
                        bean = this.getBean("&" + beanName);
                        break;
                    }

                    this.getBean(beanName);
                }
            } while(!(bean instanceof FactoryBean));

            FactoryBean<?> factory = (FactoryBean)bean;
            boolean isEagerInit;
            if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                SmartFactoryBean var10000 = (SmartFactoryBean)factory;
                ((SmartFactoryBean)factory).getClass();
                isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, this.getAccessControlContext());
            } else {
                isEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean)factory).isEagerInit();
            }

            if (isEagerInit) {
                this.getBean(beanName);
            }
        }
    }
```
此方法，在遍历`BeanDefinition`对象，来验证这些`BeanDefinition`对象是不是可以将这些描述的bean实例化，因为有些非单例的bean，接下来不应该实例化的，所以有这么一个校验的过程。
接下来：进入此方法：`this.getBean(beanName);`
最核心的方法：
```java
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
        String beanName = this.transformedBeanName(name);
        Object sharedInstance = this.getSingleton(beanName);
        Object beanInstance;
        if (sharedInstance != null && args == null) {
            if (this.logger.isTraceEnabled()) {
                if (this.isSingletonCurrentlyInCreation(beanName)) {
                    this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
                } else {
                    this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
                }
            }

            beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
        } else {
            if (this.isPrototypeCurrentlyInCreation(beanName)) {
                throw new BeanCurrentlyInCreationException(beanName);
            }

            BeanFactory parentBeanFactory = this.getParentBeanFactory();
            if (parentBeanFactory != null && !this.containsBeanDefinition(beanName)) {
                String nameToLookup = this.originalBeanName(name);
                if (parentBeanFactory instanceof AbstractBeanFactory) {
                    return ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
                }

                if (args != null) {
                    return parentBeanFactory.getBean(nameToLookup, args);
                }

                if (requiredType != null) {
                    return parentBeanFactory.getBean(nameToLookup, requiredType);
                }

                return parentBeanFactory.getBean(nameToLookup);
            }

            if (!typeCheckOnly) {
                this.markBeanAsCreated(beanName);
            }

            StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate").tag("beanName", name);

            try {
                if (requiredType != null) {
                    beanCreation.tag("beanType", requiredType::toString);
                }

                RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);
                this.checkMergedBeanDefinition(mbd, beanName, args);
                String[] dependsOn = mbd.getDependsOn();
                String[] var12;
                if (dependsOn != null) {
                    var12 = dependsOn;
                    int var13 = dependsOn.length;

                    for(int var14 = 0; var14 < var13; ++var14) {
                        String dep = var12[var14];
                        if (this.isDependent(beanName, dep)) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                        }

                        this.registerDependentBean(dep, beanName);

                        try {
                            this.getBean(dep);
                        } catch (NoSuchBeanDefinitionException var31) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "'" + beanName + "' depends on missing bean '" + dep + "'", var31);
                        }
                    }
                }

                if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                } else if (mbd.isPrototype()) {
                    var12 = null;

                    Object prototypeInstance;
                    try {
                        this.beforePrototypeCreation(beanName);
                        prototypeInstance = this.createBean(beanName, mbd, args);
                    } finally {
                        this.afterPrototypeCreation(beanName);
                    }

                    beanInstance = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                } else {
                    String scopeName = mbd.getScope();
                    if (!StringUtils.hasLength(scopeName)) {
                        throw new IllegalStateException("No scope name defined for bean ��" + beanName + "'");
                    }

                    Scope scope = (Scope)this.scopes.get(scopeName);
                    if (scope == null) {
                        throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                    }

                    try {
                        Object scopedInstance = scope.get(beanName, () -> {
                            this.beforePrototypeCreation(beanName);

                            Object var4;
                            try {
                                var4 = this.createBean(beanName, mbd, args);
                            } finally {
                                this.afterPrototypeCreation(beanName);
                            }

                            return var4;
                        });
                        beanInstance = this.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                    } catch (IllegalStateException var30) {
                        throw new ScopeNotActiveException(beanName, scopeName, var30);
                    }
                }
            } catch (BeansException var32) {
                beanCreation.tag("exception", var32.getClass().toString());
                beanCreation.tag("message", String.valueOf(var32.getMessage()));
                this.cleanupAfterBeanCreationFailure(beanName);
                throw var32;
            } finally {
                beanCreation.end();
            }
        }

        return this.adaptBeanInstance(name, beanInstance, requiredType);
    }
```
`String beanName = this.transformedBeanName(name);`此行，先认为它是校验bean的名字是不是合法，其实还有很多其他作用；
`Object sharedInstance = this.getSingleton(beanName);`此行，是从一个map中尝试拿一下，这个bean，这个map是一个ConcurrentHashMap，是常说的Spring容器，但准确的应该叫Spring单例池，但此刻肯定是拿不到的，它为什么要拿一下呢?这里有个很关键的方法：`isSingletonCurrentlyInCreation(beanName)`
```java
String beanName = this.transformedBeanName(name);
Object sharedInstance = this.getSingleton(beanName);
Object beanInstance;
if (sharedInstance != null && args == null) {
    if (this.logger.isTraceEnabled()) {
        if (this.isSingletonCurrentlyInCreation(beanName)) {
            this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
        } else {
            this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
        }
    }

    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
}
```
至此，先跳过这部分。
再回到doGetBean方法：来到：
```java
if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }
```
此处，就要进行创建对象了：
```java
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Creating instance of bean '" + beanName + "'");
        }

        RootBeanDefinition mbdToUse = mbd;
        Class<?> resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
        if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
            mbdToUse = new RootBeanDefinition(mbd);
            mbdToUse.setBeanClass(resolvedClass);
        }

        try {
            mbdToUse.prepareMethodOverrides();
        } catch (BeanDefinitionValidationException var9) {
            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", var9);
        }

        Object beanInstance;
        try {
            beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);
            if (beanInstance != null) {
                return beanInstance;
            }
        } catch (Throwable var10) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", var10);
        }

        try {
            beanInstance = this.doCreateBean(beanName, mbdToUse, args);
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Finished creating instance of bean '" + beanName + "'");
            }

            return beanInstance;
        } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) {
            throw var7;
        } catch (Throwable var8) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", var8);
        }
    }
```
上面这段代码，可以看到，就是通过`BeanDefinition`对象拿到bean的Class类的对象出来，准备创建对象，就是拿到该类的构造器等信息，来实例化。虽然是实例化了，但并不是完整的Spring bean。如下代码片段
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    @PostConstruct
    public void aa(){
        //Spring bean生命周期初始化回调方法
        System.out.println("init");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
它这一步，仅仅是创建了OneService的基本对象，@Autowired，还有AOP功能，@PostConstruct等等都没有做，仅仅是new出来了这个基本对象。
在创建的过程中，进入doCreateBean方法中：
```java
//判断是否允许循环依赖
//主要就是this.allowCircularReferences,而Spring关闭默认允许循环依赖的关键也就是这里
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }

    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}
```
## 问题：怎么关闭Spring默认的允许循环依赖
1、直接修改源码，赋值allowCircularReferences属性为false。
2、手动refresh：
```java
//1、初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext(MyConfig.class);
//2、拿到beanFactory
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
//但这样其实没有用,因为1、步已经完成了容器的初始化。
```
正确的做法：
```java
//初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext();
//先调用默认构造器，然后自己来实现其构造器中的两个关键方法：register和refresh
ac.register(MyConfig.class);
//在此关闭循环依赖
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
ac.refresh();
```
回到创建过程：
```java
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }
    //在此进行第四次后置处理器，判断是否需要AOP
    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}

Object exposedObject = bean;

try {
    //填充属性，也就是常常说的自动注入
    //里面会完成第五次和第六次后置处理器的调用
    this.populateBean(beanName, mbd, instanceWrapper);
    //初始化bean
    //里面会完成第七次和第八次后置处理器的调用
    exposedObject = this.initializeBean(beanName, exposedObject, mbd);
} catch (Throwable var18) {
    if (var18 instanceof BeanCreationException && beanName.equals(((BeanCreationException)var18).getBeanName())) {
        throw (BeanCreationException)var18;
    }

    throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", var18);
}
```
进入populateBean方法：
```java
if (hasInstAwareBpps) {
    if (pvs == null) {
        pvs = mbd.getPropertyValues();
    }

    PropertyValues pvsToUse;
    for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {
        InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();
        pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
        if (pvsToUse == null) {
            if (filteredPds == null) {
                filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            }

            pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
                return;
            }
        }
    }
}
```
此行：`pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);`完成后，完成注入，比如TwoService，这时候就注入了进来。
注意，此处是个for循环，该循环在遍历后置处理器BeanPostProcessors，然后不同的BeanPostProcessor作不同的事情，比如常说的@Autowired注解，和@Resource注解的区别，这两个注解的组件走到这里的时候，会有不同的后置处理器来处理。
至此，来看开始循环注入的问题：
首先:初始化容器
```java
AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);
```
调用refresh方法：
```java
this.refresh();
```
经过：
```java
this.invokeBeanFactoryPostProcessors(beanFactory);
```
后完成扫描。
经过：
```java
this.finishBeanFactoryInitialization(beanFactory);
```
后完成bean的初始化。在：`this.finishBeanFactoryInitialization(beanFactory);`中，又进行了实例化所有的单例，非Lazy的bean：
```java
beanFactory.preInstantiateSingletons();
```
这里面，创建对象的过程是，先new出了基本的对象，然后接着进行属性填充：
```java
this.populateBean(beanName, mbd, instanceWrapper);
```
就是在此时，填充TwoService，这时候他会从容器中去拿TwoService这个bean，就是单例池中去拿，这时候肯定拿不到。
这时候就到了上面提到的：去池子中拿，拿不到，这时候有一个很关键的判断：
`if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName))`
```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
这个判断条件是不成立的。如果该条件成立，那么就要去三级缓存中拿。
# 循环依赖类的创建流程总结：
OK，循环依赖的两个类加载的过程：
调用构造方法new出OneService对象-->如果是单例，还会把自己放到一个代表正在创建中的Set集合中，如果开启了循环依赖，就会把当前的OneService的对象放到二级缓存中-->继续走，走到populateBean要进行填充TwoService-->从容器中找，这时候找不到。此刻就有上边这个判断，是不是正在创建的bean，如果此判断成功进入，就会从三级缓存中拿出来。-->拿不到，条件也没成立，这时候，就要new出TwoService来，当然此时new出的来TwoServcie对象，也要走bean的生命周期，那么它最终还是会走到populateBean这个方法，它也会去填充属性--->从容器中找OneService的bean，拿不到，所以它又要实例化一遍OneService，但这个过程中，但是此时有个判断条件却成立了，因为OneService确实是正在创建中，它从二级缓存中拿，是能拿到的，之前的过程存进去了。这时候，拿到OneService的对象，不等于null，就给TwoService注入了。
```java
/**
 * 比如第一次加载OneService,就会把自己放入二级缓存，当OneService进行到populateBean时，就会准备注入TwoService，
 * TwoService，也一样，最后进行到populateBean，从单例池中拿OneService，拿不到，继续从三级中拿，拿不到，继续从
 * 二级中拿，拿到了，就把OneService放进三级缓存，并将二级缓存中的移除。 
 */
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    //一级缓存：即单例池
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        //从三级缓存中拿 
        singletonObject = this.earlySingletonObjects.get(beanName);
        //如果拿不到
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        //从二级缓存中拿
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        //如果拿到了 
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            //放入三级缓存中
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            //将二级缓存中的移除
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
(String), 原创(String), 163(Integer), true(Boolean), true(Boolean), true(Boolean), true(Boolean), true(Boolean), 2021-04-03 01:26:55.386(Timestamp), 2021-04-04 23:40:56.51(Timestamp), 14(Long), 1(Long), 34(Long)
2021-04-25 19:07:44.676 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.BlogMapper.updateById   : <==    Updates: 1
2021-04-25 19:07:44.712  INFO 19964 --- [http-nio-8080-exec-10] com.yi.blog.aspect.LogAspect             : Result:archivedetails
2021-04-25 19:08:03.994  INFO 19964 --- [http-nio-8080-exec-3] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/blog/34', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.blog', args=[34, {}]}
2021-04-25 19:08:04.005 DEBUG 19964 --- [http-nio-8080-exec-3] com.yi.blog.mapper.UserMapper.selectOne  : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE (id = ?) 
2021-04-25 19:08:04.005 DEBUG 19964 --- [http-nio-8080-exec-3] com.yi.blog.mapper.UserMapper.selectOne  : ==> Parameters: 1(Integer)
2021-04-25 19:08:04.016 DEBUG 19964 --- [http-nio-8080-exec-3] com.yi.blog.mapper.UserMapper.selectOne  : <==      Total: 1
2021-04-25 19:08:04.027 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.selectById   : ==>  Preparing: SELECT id,title,content,first_picture,stamp,views,appreciate,original,comments,published,recommend,create_time,update_time,blog_type_id,user_id FROM blog WHERE id=? 
2021-04-25 19:08:04.027 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.selectById   : ==> Parameters: 34(Long)
2021-04-25 19:08:04.053 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.selectById   : <==      Total: 1
2021-04-25 19:08:04.054 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:08:04.054 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:08:04.066 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:08:04.068 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.updateById   : ==>  Preparing: UPDATE blog SET title=?, content=?, stamp=?, views=?, appreciate=?, original=?, comments=?, published=?, recommend=?, create_time=?, update_time=?, blog_type_id=?, user_id=? WHERE id=? 
2021-04-25 19:08:04.069 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.updateById   : ==> Parameters: Spring(一)(String), # Spring:循环依赖
## 什么是循环依赖?

```java
@ComponentScan("com.yi")
public class MyConfig {

}
```
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
```java
@Component
public class TwoService {
    @Autowired
    OneService oneService;

    public TwoService() {
        System.out.println("Construct TwoService");
    }

    public void getOneService(){
        System.out.println(oneService);
    }
}
```
```java
public class Test {
    public static void main(String[] args) {
        //初始化Spring容器
        AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);

        ac.getBean(OneService.class).getTwoService();
    }
}
```
这四个代码片段，即展示了Spring当中的循环依赖。
明白循环依赖，首先要明白依赖注入。
# Spring：依赖注入
依赖注入是在Spring容器初始化的时候完成的。这期间有一个过程：以上述代码为例，初始化`AnnotationConfigApplicationContext`容器，首先读取`MyConfig`类，扫描包下的Spring管理的注解的类，然后利用这些类的信息，进行bean的初始化。
初始化bean：1、2、3、4、5、6、...N步,分好多步，接下来，看一下这些具体的步骤。
## Spring bean的初始化
普通类的初始化，简单的来说，就是.java结尾的类，在经过编译后，生成.class字节码文件，然后jvm读取这些文件，将读取的类信息，放置到方法区，等到new的时候，利用这些信息，在堆空间开辟空间，产生一个对象。
而Spring bean的初始化，要经过更繁琐的过程。
### scan:
将扫描到的由Spring管理的类，生成类信息。
### parse：
接下来，Spring底层会解析这些类的信息，将一个一个的类，生成一个一个的`BeanDefinition`接口的实现类。
这些`BeanDefinition`类中，保存的是扫描到的类的信息，信息大致有：beanSocpe，扫描到的类是不是单例的？isLazy，扫描到的类是不是标注了`@Lazy`注解，是不是懒加载？不同的信息，Spring将做不同的策略。
### put map：
接下来，把这些`BeanDefinition`对象，放置到一个map中，map的key即扫描类的类名，value即`BeanDefinition`对象。
### 实例化：
接下来，将遍历这个map，然后实例化。实例化出的对象，依然放到新的map当中(`@Lazy`、原型，等特殊对象，此刻不会实例化。
#### Spring bean的生命周期
```java
public void refresh() throws BeansException, IllegalStateException {
        synchronized(this.startupShutdownMonitor) {
            StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");
            this.prepareRefresh();
            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
            this.prepareBeanFactory(beanFactory);

            try {
                this.postProcessBeanFactory(beanFactory);
                StartupStep beanPostProcess = this.applicationStartup.start("spring.context.beans.post-process");
                this.invokeBeanFactoryPostProcessors(beanFactory);
                this.registerBeanPostProcessors(beanFactory);
                beanPostProcess.end();
                this.initMessageSource();
                this.initApplicationEventMulticaster();
                this.onRefresh();
                this.registerListeners();
                this.finishBeanFactoryInitialization(beanFactory);
                this.finishRefresh();
            } catch (BeansException var10) {
                if (this.logger.isWarnEnabled()) {
                    this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var10);
                }

                this.destroyBeans();
                this.cancelRefresh(var10);
                throw var10;
            } finally {
                this.resetCommonCaches();
                contextRefresh.end();
            }

        }
    }
```
`this.invokeBeanFactoryPostProcessors(beanFactory);`此行完成了Spring bean的扫描，此刻，`BeanDefinition`对象已经全部加载到了map当中。
`this.finishBeanFactoryInitialization(beanFactory);`此行完成了实例化。
bean的生命周期，即在`this.finishBeanFactoryInitialization(beanFactory);`中。
进入此方法：
```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
        if (beanFactory.containsBean("conversionService") && beanFactory.isTypeMatch("conversionService", ConversionService.class)) {
            beanFactory.setConversionService((ConversionService)beanFactory.getBean("conversionService", ConversionService.class));
        }

        if (!beanFactory.hasEmbeddedValueResolver()) {
            beanFactory.addEmbeddedValueResolver((strVal) -> {
                return this.getEnvironment().resolvePlaceholders(strVal);
            });
        }

        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
        String[] var3 = weaverAwareNames;
        int var4 = weaverAwareNames.length;

        for(int var5 = 0; var5 < var4; ++var5) {
            String weaverAwareName = var3[var5];
            this.getBean(weaverAwareName);
        }

        beanFactory.setTempClassLoader((ClassLoader)null);
        beanFactory.freezeConfiguration();
        beanFactory.preInstantiateSingletons();
    }
```
`beanFactory.preInstantiateSingletons();`此行实例化所有的单例，非Lazy的。
进入此方法：
```java
public void preInstantiateSingletons() throws BeansException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Pre-instantiating singletons in " + this);
        }

        List<String> beanNames = new ArrayList(this.beanDefinitionNames);
        Iterator var2 = beanNames.iterator();

        while(true) {
            String beanName;
            Object bean;
            do {
                while(true) {
                    RootBeanDefinition bd;
                    do {
                        do {
                            do {
                                if (!var2.hasNext()) {
                                    var2 = beanNames.iterator();

                                    while(var2.hasNext()) {
                                        beanName = (String)var2.next();
                                        Object singletonInstance = this.getSingleton(beanName);
                                        if (singletonInstance instanceof SmartInitializingSingleton) {
                                            StartupStep smartInitialize = this.getApplicationStartup().start("spring.beans.smart-initialize").tag("beanName", beanName);
                                            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;
                                            if (System.getSecurityManager() != null) {
                                                AccessController.doPrivileged(() -> {
                                                    smartSingleton.afterSingletonsInstantiated();
                                                    return null;
                                                }, this.getAccessControlContext());
                                            } else {
                                                smartSingleton.afterSingletonsInstantiated();
                                            }

                                            smartInitialize.end();
                                        }
                                    }

                                    return;
                                }

                                beanName = (String)var2.next();
                                bd = this.getMergedLocalBeanDefinition(beanName);
                            } while(bd.isAbstract());
                        } while(!bd.isSingleton());
                    } while(bd.isLazyInit());

                    if (this.isFactoryBean(beanName)) {
                        bean = this.getBean("&" + beanName);
                        break;
                    }

                    this.getBean(beanName);
                }
            } while(!(bean instanceof FactoryBean));

            FactoryBean<?> factory = (FactoryBean)bean;
            boolean isEagerInit;
            if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                SmartFactoryBean var10000 = (SmartFactoryBean)factory;
                ((SmartFactoryBean)factory).getClass();
                isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, this.getAccessControlContext());
            } else {
                isEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean)factory).isEagerInit();
            }

            if (isEagerInit) {
                this.getBean(beanName);
            }
        }
    }
```
此方法，在遍历`BeanDefinition`对象，来验证这些`BeanDefinition`对象是不是可以将这些描述的bean实例化，因为有些非单例的bean，接下来不应该实例化的，所以有这么一个校验的过程。
接下来：进入此方法：`this.getBean(beanName);`
最核心的方法：
```java
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
        String beanName = this.transformedBeanName(name);
        Object sharedInstance = this.getSingleton(beanName);
        Object beanInstance;
        if (sharedInstance != null && args == null) {
            if (this.logger.isTraceEnabled()) {
                if (this.isSingletonCurrentlyInCreation(beanName)) {
                    this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
                } else {
                    this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
                }
            }

            beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
        } else {
            if (this.isPrototypeCurrentlyInCreation(beanName)) {
                throw new BeanCurrentlyInCreationException(beanName);
            }

            BeanFactory parentBeanFactory = this.getParentBeanFactory();
            if (parentBeanFactory != null && !this.containsBeanDefinition(beanName)) {
                String nameToLookup = this.originalBeanName(name);
                if (parentBeanFactory instanceof AbstractBeanFactory) {
                    return ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
                }

                if (args != null) {
                    return parentBeanFactory.getBean(nameToLookup, args);
                }

                if (requiredType != null) {
                    return parentBeanFactory.getBean(nameToLookup, requiredType);
                }

                return parentBeanFactory.getBean(nameToLookup);
            }

            if (!typeCheckOnly) {
                this.markBeanAsCreated(beanName);
            }

            StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate").tag("beanName", name);

            try {
                if (requiredType != null) {
                    beanCreation.tag("beanType", requiredType::toString);
                }

                RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);
                this.checkMergedBeanDefinition(mbd, beanName, args);
                String[] dependsOn = mbd.getDependsOn();
                String[] var12;
                if (dependsOn != null) {
                    var12 = dependsOn;
                    int var13 = dependsOn.length;

                    for(int var14 = 0; var14 < var13; ++var14) {
                        String dep = var12[var14];
                        if (this.isDependent(beanName, dep)) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                        }

                        this.registerDependentBean(dep, beanName);

                        try {
                            this.getBean(dep);
                        } catch (NoSuchBeanDefinitionException var31) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "'" + beanName + "' depends on missing bean '" + dep + "'", var31);
                        }
                    }
                }

                if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                } else if (mbd.isPrototype()) {
                    var12 = null;

                    Object prototypeInstance;
                    try {
                        this.beforePrototypeCreation(beanName);
                        prototypeInstance = this.createBean(beanName, mbd, args);
                    } finally {
                        this.afterPrototypeCreation(beanName);
                    }

                    beanInstance = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                } else {
                    String scopeName = mbd.getScope();
                    if (!StringUtils.hasLength(scopeName)) {
                        throw new IllegalStateException("No scope name defined for bean ��" + beanName + "'");
                    }

                    Scope scope = (Scope)this.scopes.get(scopeName);
                    if (scope == null) {
                        throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                    }

                    try {
                        Object scopedInstance = scope.get(beanName, () -> {
                            this.beforePrototypeCreation(beanName);

                            Object var4;
                            try {
                                var4 = this.createBean(beanName, mbd, args);
                            } finally {
                                this.afterPrototypeCreation(beanName);
                            }

                            return var4;
                        });
                        beanInstance = this.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                    } catch (IllegalStateException var30) {
                        throw new ScopeNotActiveException(beanName, scopeName, var30);
                    }
                }
            } catch (BeansException var32) {
                beanCreation.tag("exception", var32.getClass().toString());
                beanCreation.tag("message", String.valueOf(var32.getMessage()));
                this.cleanupAfterBeanCreationFailure(beanName);
                throw var32;
            } finally {
                beanCreation.end();
            }
        }

        return this.adaptBeanInstance(name, beanInstance, requiredType);
    }
```
`String beanName = this.transformedBeanName(name);`此行，先认为它是校验bean的名字是不是合法，其实还有很多其他作用；
`Object sharedInstance = this.getSingleton(beanName);`此行，是从一个map中尝试拿一下，这个bean，这个map是一个ConcurrentHashMap，是常说的Spring容器，但准确的应该叫Spring单例池，但此刻肯定是拿不到的，它为什么要拿一下呢?这里有个很关键的方法：`isSingletonCurrentlyInCreation(beanName)`
```java
String beanName = this.transformedBeanName(name);
Object sharedInstance = this.getSingleton(beanName);
Object beanInstance;
if (sharedInstance != null && args == null) {
    if (this.logger.isTraceEnabled()) {
        if (this.isSingletonCurrentlyInCreation(beanName)) {
            this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
        } else {
            this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
        }
    }

    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
}
```
至此，先跳过这部分。
再回到doGetBean方法：来到：
```java
if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }
```
此处，就要进行创建对象了：
```java
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Creating instance of bean '" + beanName + "'");
        }

        RootBeanDefinition mbdToUse = mbd;
        Class<?> resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
        if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
            mbdToUse = new RootBeanDefinition(mbd);
            mbdToUse.setBeanClass(resolvedClass);
        }

        try {
            mbdToUse.prepareMethodOverrides();
        } catch (BeanDefinitionValidationException var9) {
            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", var9);
        }

        Object beanInstance;
        try {
            beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);
            if (beanInstance != null) {
                return beanInstance;
            }
        } catch (Throwable var10) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", var10);
        }

        try {
            beanInstance = this.doCreateBean(beanName, mbdToUse, args);
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Finished creating instance of bean '" + beanName + "'");
            }

            return beanInstance;
        } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) {
            throw var7;
        } catch (Throwable var8) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", var8);
        }
    }
```
上面这段代码，可以看到，就是通过`BeanDefinition`对象拿到bean的Class类的对象出来，准备创建对象，就是拿到该类的构造器等信息，来实例化。虽然是实例化了，但并不是完整的Spring bean。如下代码片段
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    @PostConstruct
    public void aa(){
        //Spring bean生命周期初始化回调方法
        System.out.println("init");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
它这一步，仅仅是创建了OneService的基本对象，@Autowired，还有AOP功能，@PostConstruct等等都没有做，仅仅是new出来了这个基本对象。
在创建的过程中，进入doCreateBean方法中：
```java
//判断是否允许循环依赖
//主要就是this.allowCircularReferences,而Spring关闭默认允许循环依赖的关键也就是这里
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }

    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}
```
## 问题：怎么关闭Spring默认的允许循环依赖
1、直接修改源码，赋值allowCircularReferences属性为false。
2、手动refresh：
```java
//1、初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext(MyConfig.class);
//2、拿到beanFactory
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
//但这样其实没有用,因为1、步已经完成了容器的初始化。
```
正确的做法：
```java
//初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext();
//先调用默认构造器，然后自己来实现其构造器中的两个关键方法：register和refresh
ac.register(MyConfig.class);
//在此关闭循环依赖
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
ac.refresh();
```
回到创建过程：
```java
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }
    //在此进行第四次后置处理器，判断是否需要AOP
    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}

Object exposedObject = bean;

try {
    //填充属性，也就是常常说的自动注入
    //里面会完成第五次和第六次后置处理器的调用
    this.populateBean(beanName, mbd, instanceWrapper);
    //初始化bean
    //里面会完成第七次和第八次后置处理器的调用
    exposedObject = this.initializeBean(beanName, exposedObject, mbd);
} catch (Throwable var18) {
    if (var18 instanceof BeanCreationException && beanName.equals(((BeanCreationException)var18).getBeanName())) {
        throw (BeanCreationException)var18;
    }

    throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", var18);
}
```
进入populateBean方法：
```java
if (hasInstAwareBpps) {
    if (pvs == null) {
        pvs = mbd.getPropertyValues();
    }

    PropertyValues pvsToUse;
    for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {
        InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();
        pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
        if (pvsToUse == null) {
            if (filteredPds == null) {
                filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            }

            pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
                return;
            }
        }
    }
}
```
此行：`pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);`完成后，完成注入，比如TwoService，这时候就注入了进来。
注意，此处是个for循环，该循环在遍历后置处理器BeanPostProcessors，然后不同的BeanPostProcessor作不同的事情，比如常说的@Autowired注解，和@Resource注解的区别，这两个注解的组件走到这里的时候，会有不同的后置处理器来处理。
至此，来看开始循环注入的问题：
首先:初始化容器
```java
AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);
```
调用refresh方法：
```java
this.refresh();
```
经过：
```java
this.invokeBeanFactoryPostProcessors(beanFactory);
```
后完成扫描。
经过：
```java
this.finishBeanFactoryInitialization(beanFactory);
```
后完成bean的初始化。在：`this.finishBeanFactoryInitialization(beanFactory);`中，又进行了实例化所有的单例，非Lazy的bean：
```java
beanFactory.preInstantiateSingletons();
```
这里面，创建对象的过程是，先new出了基本的对象，然后接着进行属性填充：
```java
this.populateBean(beanName, mbd, instanceWrapper);
```
就是在此时，填充TwoService，这时候他会从容器中去拿TwoService这个bean，就是单例池中去拿，这时候肯定拿不到。
这时候就到了上面提到的：去池子中拿，拿不到，这时候有一个很关键的判断：
`if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName))`
```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
这个判断条件是不成立的。如果该条件成立，那么就要去三级缓存中拿。
# 循环依赖类的创建流程总结：
OK，循环依赖的两个类加载的过程：
调用构造方法new出OneService对象-->如果是单例，还会把自己放到一个代表正在创建中的Set集合中，如果开启了循环依赖，就会把当前的OneService的对象放到二级缓存中-->继续走，走到populateBean要进行填充TwoService-->从容器中找，这时候找不到。此刻就有上边这个判断，是不是正在创建的bean，如果此判断成功进入，就会从三级缓存中拿出来。-->拿不到，条件也没成立，这时候，就要new出TwoService来，当然此时new出的来TwoServcie对象，也要走bean的生命周期，那么它最终还是会走到populateBean这个方法，它也会去填充属性--->从容器中找OneService的bean，拿不到，所以它又要实例化一遍OneService，但这个过程中，但是此时有个判断条件却成立了，因为OneService确实是正在创建中，它从二级缓存中拿，是能拿到的，之前的过程存进去了。这时候，拿到OneService的对象，不等于null，就给TwoService注入了。
```java
/**
 * 比如第一次加载OneService,就会把自己放入二级缓存，当OneService进行到populateBean时，就会准备注入TwoService，
 * TwoService，也一样，最后进行到populateBean，从单例池中拿OneService，拿不到，继续从三级中拿，拿不到，继续从
 * 二级中拿，拿到了，就把OneService放进三级缓存，并将二级缓存中的移除。 
 */
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    //一级缓存：即单例池
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        //从三级缓存中拿 
        singletonObject = this.earlySingletonObjects.get(beanName);
        //如果拿不到
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        //从二级缓存中拿
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        //如果拿到了 
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            //放入三级缓存中
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            //将二级缓存中的移除
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
(String), 原创(String), 164(Integer), true(Boolean), true(Boolean), true(Boolean), true(Boolean), true(Boolean), 2021-04-03 01:26:55.386(Timestamp), 2021-04-04 23:40:56.51(Timestamp), 14(Long), 1(Long), 34(Long)
2021-04-25 19:08:04.091 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.updateById   : <==    Updates: 1
2021-04-25 19:08:04.126  INFO 19964 --- [http-nio-8080-exec-3] com.yi.blog.aspect.LogAspect             : Result:archivedetails
2021-04-25 19:08:13.313  INFO 19964 --- [http-nio-8080-exec-5] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/blog/34', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.blog', args=[34, {}]}
2021-04-25 19:08:13.324 DEBUG 19964 --- [http-nio-8080-exec-5] com.yi.blog.mapper.UserMapper.selectOne  : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE (id = ?) 
2021-04-25 19:08:13.325 DEBUG 19964 --- [http-nio-8080-exec-5] com.yi.blog.mapper.UserMapper.selectOne  : ==> Parameters: 1(Integer)
2021-04-25 19:08:13.336 DEBUG 19964 --- [http-nio-8080-exec-5] com.yi.blog.mapper.UserMapper.selectOne  : <==      Total: 1
2021-04-25 19:08:13.346 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.selectById   : ==>  Preparing: SELECT id,title,content,first_picture,stamp,views,appreciate,original,comments,published,recommend,create_time,update_time,blog_type_id,user_id FROM blog WHERE id=? 
2021-04-25 19:08:13.346 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.selectById   : ==> Parameters: 34(Long)
2021-04-25 19:08:13.369 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.selectById   : <==      Total: 1
2021-04-25 19:08:13.371 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:08:13.371 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:08:13.381 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:08:13.383 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.updateById   : ==>  Preparing: UPDATE blog SET title=?, content=?, stamp=?, views=?, appreciate=?, original=?, comments=?, published=?, recommend=?, create_time=?, update_time=?, blog_type_id=?, user_id=? WHERE id=? 
2021-04-25 19:08:13.383 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.updateById   : ==> Parameters: Spring(一)(String), # Spring:循环依赖
## 什么是循环依赖?

```java
@ComponentScan("com.yi")
public class MyConfig {

}
```
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
```java
@Component
public class TwoService {
    @Autowired
    OneService oneService;

    public TwoService() {
        System.out.println("Construct TwoService");
    }

    public void getOneService(){
        System.out.println(oneService);
    }
}
```
```java
public class Test {
    public static void main(String[] args) {
        //初始化Spring容器
        AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);

        ac.getBean(OneService.class).getTwoService();
    }
}
```
这四个代码片段，即展示了Spring当中的循环依赖。
明白循环依赖，首先要明白依赖注入。
# Spring：依赖注入
依赖注入是在Spring容器初始化的时候完成的。这期间有一个过程：以上述代码为例，初始化`AnnotationConfigApplicationContext`容器，首先读取`MyConfig`类，扫描包下的Spring管理的注解的类，然后利用这些类的信息，进行bean的初始化。
初始化bean：1、2、3、4、5、6、...N步,分好多步，接下来，看一下这些具体的步骤。
## Spring bean的初始化
普通类的初始化，简单的来说，就是.java结尾的类，在经过编译后，生成.class字节码文件，然后jvm读取这些文件，将读取的类信息，放置到方法区，等到new的时候，利用这些信息，在堆空间开辟空间，产生一个对象。
而Spring bean的初始化，要经过更繁琐的过程。
### scan:
将扫描到的由Spring管理的类，生成类信息。
### parse：
接下来，Spring底层会解析这些类的信息，将一个一个的类，生成一个一个的`BeanDefinition`接口的实现类。
这些`BeanDefinition`类中，保存的是扫描到的类的信息，信息大致有：beanSocpe，扫描到的类是不是单例的？isLazy，扫描到的类是不是标注了`@Lazy`注解，是不是懒加载？不同的信息，Spring将做不同的策略。
### put map：
接下来，把这些`BeanDefinition`对象，放置到一个map中，map的key即扫描类的类名，value即`BeanDefinition`对象。
### 实例化：
接下来，将遍历这个map，然后实例化。实例化出的对象，依然放到新的map当中(`@Lazy`、原型，等特殊对象，此刻不会实例化。
#### Spring bean的生命周期
```java
public void refresh() throws BeansException, IllegalStateException {
        synchronized(this.startupShutdownMonitor) {
            StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");
            this.prepareRefresh();
            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
            this.prepareBeanFactory(beanFactory);

            try {
                this.postProcessBeanFactory(beanFactory);
                StartupStep beanPostProcess = this.applicationStartup.start("spring.context.beans.post-process");
                this.invokeBeanFactoryPostProcessors(beanFactory);
                this.registerBeanPostProcessors(beanFactory);
                beanPostProcess.end();
                this.initMessageSource();
                this.initApplicationEventMulticaster();
                this.onRefresh();
                this.registerListeners();
                this.finishBeanFactoryInitialization(beanFactory);
                this.finishRefresh();
            } catch (BeansException var10) {
                if (this.logger.isWarnEnabled()) {
                    this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var10);
                }

                this.destroyBeans();
                this.cancelRefresh(var10);
                throw var10;
            } finally {
                this.resetCommonCaches();
                contextRefresh.end();
            }

        }
    }
```
`this.invokeBeanFactoryPostProcessors(beanFactory);`此行完成了Spring bean的扫描，此刻，`BeanDefinition`对象已经全部加载到了map当中。
`this.finishBeanFactoryInitialization(beanFactory);`此行完成了实例化。
bean的生命周期，即在`this.finishBeanFactoryInitialization(beanFactory);`中。
进入此方法：
```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
        if (beanFactory.containsBean("conversionService") && beanFactory.isTypeMatch("conversionService", ConversionService.class)) {
            beanFactory.setConversionService((ConversionService)beanFactory.getBean("conversionService", ConversionService.class));
        }

        if (!beanFactory.hasEmbeddedValueResolver()) {
            beanFactory.addEmbeddedValueResolver((strVal) -> {
                return this.getEnvironment().resolvePlaceholders(strVal);
            });
        }

        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
        String[] var3 = weaverAwareNames;
        int var4 = weaverAwareNames.length;

        for(int var5 = 0; var5 < var4; ++var5) {
            String weaverAwareName = var3[var5];
            this.getBean(weaverAwareName);
        }

        beanFactory.setTempClassLoader((ClassLoader)null);
        beanFactory.freezeConfiguration();
        beanFactory.preInstantiateSingletons();
    }
```
`beanFactory.preInstantiateSingletons();`此行实例化所有的单例，非Lazy的。
进入此方法：
```java
public void preInstantiateSingletons() throws BeansException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Pre-instantiating singletons in " + this);
        }

        List<String> beanNames = new ArrayList(this.beanDefinitionNames);
        Iterator var2 = beanNames.iterator();

        while(true) {
            String beanName;
            Object bean;
            do {
                while(true) {
                    RootBeanDefinition bd;
                    do {
                        do {
                            do {
                                if (!var2.hasNext()) {
                                    var2 = beanNames.iterator();

                                    while(var2.hasNext()) {
                                        beanName = (String)var2.next();
                                        Object singletonInstance = this.getSingleton(beanName);
                                        if (singletonInstance instanceof SmartInitializingSingleton) {
                                            StartupStep smartInitialize = this.getApplicationStartup().start("spring.beans.smart-initialize").tag("beanName", beanName);
                                            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;
                                            if (System.getSecurityManager() != null) {
                                                AccessController.doPrivileged(() -> {
                                                    smartSingleton.afterSingletonsInstantiated();
                                                    return null;
                                                }, this.getAccessControlContext());
                                            } else {
                                                smartSingleton.afterSingletonsInstantiated();
                                            }

                                            smartInitialize.end();
                                        }
                                    }

                                    return;
                                }

                                beanName = (String)var2.next();
                                bd = this.getMergedLocalBeanDefinition(beanName);
                            } while(bd.isAbstract());
                        } while(!bd.isSingleton());
                    } while(bd.isLazyInit());

                    if (this.isFactoryBean(beanName)) {
                        bean = this.getBean("&" + beanName);
                        break;
                    }

                    this.getBean(beanName);
                }
            } while(!(bean instanceof FactoryBean));

            FactoryBean<?> factory = (FactoryBean)bean;
            boolean isEagerInit;
            if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                SmartFactoryBean var10000 = (SmartFactoryBean)factory;
                ((SmartFactoryBean)factory).getClass();
                isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, this.getAccessControlContext());
            } else {
                isEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean)factory).isEagerInit();
            }

            if (isEagerInit) {
                this.getBean(beanName);
            }
        }
    }
```
此方法，在遍历`BeanDefinition`对象，来验证这些`BeanDefinition`对象是不是可以将这些描述的bean实例化，因为有些非单例的bean，接下来不应该实例化的，所以有这么一个校验的过程。
接下来：进入此方法：`this.getBean(beanName);`
最核心的方法：
```java
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
        String beanName = this.transformedBeanName(name);
        Object sharedInstance = this.getSingleton(beanName);
        Object beanInstance;
        if (sharedInstance != null && args == null) {
            if (this.logger.isTraceEnabled()) {
                if (this.isSingletonCurrentlyInCreation(beanName)) {
                    this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
                } else {
                    this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
                }
            }

            beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
        } else {
            if (this.isPrototypeCurrentlyInCreation(beanName)) {
                throw new BeanCurrentlyInCreationException(beanName);
            }

            BeanFactory parentBeanFactory = this.getParentBeanFactory();
            if (parentBeanFactory != null && !this.containsBeanDefinition(beanName)) {
                String nameToLookup = this.originalBeanName(name);
                if (parentBeanFactory instanceof AbstractBeanFactory) {
                    return ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
                }

                if (args != null) {
                    return parentBeanFactory.getBean(nameToLookup, args);
                }

                if (requiredType != null) {
                    return parentBeanFactory.getBean(nameToLookup, requiredType);
                }

                return parentBeanFactory.getBean(nameToLookup);
            }

            if (!typeCheckOnly) {
                this.markBeanAsCreated(beanName);
            }

            StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate").tag("beanName", name);

            try {
                if (requiredType != null) {
                    beanCreation.tag("beanType", requiredType::toString);
                }

                RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);
                this.checkMergedBeanDefinition(mbd, beanName, args);
                String[] dependsOn = mbd.getDependsOn();
                String[] var12;
                if (dependsOn != null) {
                    var12 = dependsOn;
                    int var13 = dependsOn.length;

                    for(int var14 = 0; var14 < var13; ++var14) {
                        String dep = var12[var14];
                        if (this.isDependent(beanName, dep)) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                        }

                        this.registerDependentBean(dep, beanName);

                        try {
                            this.getBean(dep);
                        } catch (NoSuchBeanDefinitionException var31) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "'" + beanName + "' depends on missing bean '" + dep + "'", var31);
                        }
                    }
                }

                if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                } else if (mbd.isPrototype()) {
                    var12 = null;

                    Object prototypeInstance;
                    try {
                        this.beforePrototypeCreation(beanName);
                        prototypeInstance = this.createBean(beanName, mbd, args);
                    } finally {
                        this.afterPrototypeCreation(beanName);
                    }

                    beanInstance = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                } else {
                    String scopeName = mbd.getScope();
                    if (!StringUtils.hasLength(scopeName)) {
                        throw new IllegalStateException("No scope name defined for bean ��" + beanName + "'");
                    }

                    Scope scope = (Scope)this.scopes.get(scopeName);
                    if (scope == null) {
                        throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                    }

                    try {
                        Object scopedInstance = scope.get(beanName, () -> {
                            this.beforePrototypeCreation(beanName);

                            Object var4;
                            try {
                                var4 = this.createBean(beanName, mbd, args);
                            } finally {
                                this.afterPrototypeCreation(beanName);
                            }

                            return var4;
                        });
                        beanInstance = this.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                    } catch (IllegalStateException var30) {
                        throw new ScopeNotActiveException(beanName, scopeName, var30);
                    }
                }
            } catch (BeansException var32) {
                beanCreation.tag("exception", var32.getClass().toString());
                beanCreation.tag("message", String.valueOf(var32.getMessage()));
                this.cleanupAfterBeanCreationFailure(beanName);
                throw var32;
            } finally {
                beanCreation.end();
            }
        }

        return this.adaptBeanInstance(name, beanInstance, requiredType);
    }
```
`String beanName = this.transformedBeanName(name);`此行，先认为它是校验bean的名字是不是合法，其实还有很多其他作用；
`Object sharedInstance = this.getSingleton(beanName);`此行，是从一个map中尝试拿一下，这个bean，这个map是一个ConcurrentHashMap，是常说的Spring容器，但准确的应该叫Spring单例池，但此刻肯定是拿不到的，它为什么要拿一下呢?这里有个很关键的方法：`isSingletonCurrentlyInCreation(beanName)`
```java
String beanName = this.transformedBeanName(name);
Object sharedInstance = this.getSingleton(beanName);
Object beanInstance;
if (sharedInstance != null && args == null) {
    if (this.logger.isTraceEnabled()) {
        if (this.isSingletonCurrentlyInCreation(beanName)) {
            this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
        } else {
            this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
        }
    }

    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
}
```
至此，先跳过这部分。
再回到doGetBean方法：来到：
```java
if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }
```
此处，就要进行创建对象了：
```java
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Creating instance of bean '" + beanName + "'");
        }

        RootBeanDefinition mbdToUse = mbd;
        Class<?> resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
        if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
            mbdToUse = new RootBeanDefinition(mbd);
            mbdToUse.setBeanClass(resolvedClass);
        }

        try {
            mbdToUse.prepareMethodOverrides();
        } catch (BeanDefinitionValidationException var9) {
            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", var9);
        }

        Object beanInstance;
        try {
            beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);
            if (beanInstance != null) {
                return beanInstance;
            }
        } catch (Throwable var10) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", var10);
        }

        try {
            beanInstance = this.doCreateBean(beanName, mbdToUse, args);
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Finished creating instance of bean '" + beanName + "'");
            }

            return beanInstance;
        } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) {
            throw var7;
        } catch (Throwable var8) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", var8);
        }
    }
```
上面这段代码，可以看到，就是通过`BeanDefinition`对象拿到bean的Class类的对象出来，准备创建对象，就是拿到该类的构造器等信息，来实例化。虽然是实例化了，但并不是完整的Spring bean。如下代码片段
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    @PostConstruct
    public void aa(){
        //Spring bean生命周期初始化回调方法
        System.out.println("init");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
它这一步，仅仅是创建了OneService的基本对象，@Autowired，还有AOP功能，@PostConstruct等等都没有做，仅仅是new出来了这个基本对象。
在创建的过程中，进入doCreateBean方法中：
```java
//判断是否允许循环依赖
//主要就是this.allowCircularReferences,而Spring关闭默认允许循环依赖的关键也就是这里
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }

    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}
```
## 问题：怎么关闭Spring默认的允许循环依赖
1、直接修改源码，赋值allowCircularReferences属性为false。
2、手动refresh：
```java
//1、初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext(MyConfig.class);
//2、拿到beanFactory
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
//但这样其实没有用,因为1、步已经完成了容器的初始化。
```
正确的做法：
```java
//初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext();
//先调用默认构造器，然后自己来实现其构造器中的两个关键方法：register和refresh
ac.register(MyConfig.class);
//在此关闭循环依赖
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
ac.refresh();
```
回到创建过程：
```java
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }
    //在此进行第四次后置处理器，判断是否需要AOP
    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}

Object exposedObject = bean;

try {
    //填充属性，也就是常常说的自动注入
    //里面会完成第五次和第六次后置处理器的调用
    this.populateBean(beanName, mbd, instanceWrapper);
    //初始化bean
    //里面会完成第七次和第八次后置处理器的调用
    exposedObject = this.initializeBean(beanName, exposedObject, mbd);
} catch (Throwable var18) {
    if (var18 instanceof BeanCreationException && beanName.equals(((BeanCreationException)var18).getBeanName())) {
        throw (BeanCreationException)var18;
    }

    throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", var18);
}
```
进入populateBean方法：
```java
if (hasInstAwareBpps) {
    if (pvs == null) {
        pvs = mbd.getPropertyValues();
    }

    PropertyValues pvsToUse;
    for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {
        InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();
        pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
        if (pvsToUse == null) {
            if (filteredPds == null) {
                filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            }

            pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
                return;
            }
        }
    }
}
```
此行：`pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);`完成后，完成注入，比如TwoService，这时候就注入了进来。
注意，此处是个for循环，该循环在遍历后置处理器BeanPostProcessors，然后不同的BeanPostProcessor作不同的事情，比如常说的@Autowired注解，和@Resource注解的区别，这两个注解的组件走到这里的时候，会有不同的后置处理器来处理。
至此，来看开始循环注入的问题：
首先:初始化容器
```java
AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);
```
调用refresh方法：
```java
this.refresh();
```
经过：
```java
this.invokeBeanFactoryPostProcessors(beanFactory);
```
后完成扫描。
经过：
```java
this.finishBeanFactoryInitialization(beanFactory);
```
后完成bean的初始化。在：`this.finishBeanFactoryInitialization(beanFactory);`中，又进行了实例化所有的单例，非Lazy的bean：
```java
beanFactory.preInstantiateSingletons();
```
这里面，创建对象的过程是，先new出了基本的对象，然后接着进行属性填充：
```java
this.populateBean(beanName, mbd, instanceWrapper);
```
就是在此时，填充TwoService，这时候他会从容器中去拿TwoService这个bean，就是单例池中去拿，这时候肯定拿不到。
这时候就到了上面提到的：去池子中拿，拿不到，这时候有一个很关键的判断：
`if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName))`
```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
这个判断条件是不成立的。如果该条件成立，那么就要去三级缓存中拿。
# 循环依赖类的创建流程总结：
OK，循环依赖的两个类加载的过程：
调用构造方法new出OneService对象-->如果是单例，还会把自己放到一个代表正在创建中的Set集合中，如果开启了循环依赖，就会把当前的OneService的对象放到二级缓存中-->继续走，走到populateBean要进行填充TwoService-->从容器中找，这时候找不到。此刻就有上边这个判断，是不是正在创建的bean，如果此判断成功进入，就会从三级缓存中拿出来。-->拿不到，条件也没成立，这时候，就要new出TwoService来，当然此时new出的来TwoServcie对象，也要走bean的生命周期，那么它最终还是会走到populateBean这个方法，它也会去填充属性--->从容器中找OneService的bean，拿不到，所以它又要实例化一遍OneService，但这个过程中，但是此时有个判断条件却成立了，因为OneService确实是正在创建中，它从二级缓存中拿，是能拿到的，之前的过程存进去了。这时候，拿到OneService的对象，不等于null，就给TwoService注入了。
```java
/**
 * 比如第一次加载OneService,就会把自己放入二级缓存，当OneService进行到populateBean时，就会准备注入TwoService，
 * TwoService，也一样，最后进行到populateBean，从单例池中拿OneService，拿不到，继续从三级中拿，拿不到，继续从
 * 二级中拿，拿到了，就把OneService放进三级缓存，并将二级缓存中的移除。 
 */
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    //一级缓存：即单例池
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        //从三级缓存中拿 
        singletonObject = this.earlySingletonObjects.get(beanName);
        //如果拿不到
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        //从二级缓存中拿
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        //如果拿到了 
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            //放入三级缓存中
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            //将二级缓存中的移除
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
(String), 原创(String), 165(Integer), true(Boolean), true(Boolean), true(Boolean), true(Boolean), true(Boolean), 2021-04-03 01:26:55.386(Timestamp), 2021-04-04 23:40:56.51(Timestamp), 14(Long), 1(Long), 34(Long)
2021-04-25 19:08:13.407 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.updateById   : <==    Updates: 1
2021-04-25 19:08:13.443  INFO 19964 --- [http-nio-8080-exec-5] com.yi.blog.aspect.LogAspect             : Result:archivedetails
2021-04-25 19:09:35.527  INFO 19964 --- [http-nio-8080-exec-5] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/blog/34', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.blog', args=[34, {}]}
2021-04-25 19:09:35.538 DEBUG 19964 --- [http-nio-8080-exec-5] com.yi.blog.mapper.UserMapper.selectOne  : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE (id = ?) 
2021-04-25 19:09:35.538 DEBUG 19964 --- [http-nio-8080-exec-5] com.yi.blog.mapper.UserMapper.selectOne  : ==> Parameters: 1(Integer)
2021-04-25 19:09:35.549 DEBUG 19964 --- [http-nio-8080-exec-5] com.yi.blog.mapper.UserMapper.selectOne  : <==      Total: 1
2021-04-25 19:09:35.559 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.selectById   : ==>  Preparing: SELECT id,title,content,first_picture,stamp,views,appreciate,original,comments,published,recommend,create_time,update_time,blog_type_id,user_id FROM blog WHERE id=? 
2021-04-25 19:09:35.559 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.selectById   : ==> Parameters: 34(Long)
2021-04-25 19:09:35.584 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.selectById   : <==      Total: 1
2021-04-25 19:09:35.585 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:09:35.585 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:09:35.595 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:09:35.596 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.updateById   : ==>  Preparing: UPDATE blog SET title=?, content=?, stamp=?, views=?, appreciate=?, original=?, comments=?, published=?, recommend=?, create_time=?, update_time=?, blog_type_id=?, user_id=? WHERE id=? 
2021-04-25 19:09:35.599 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.updateById   : ==> Parameters: Spring(一)(String), # Spring:循环依赖
## 什么是循环依赖?

```java
@ComponentScan("com.yi")
public class MyConfig {

}
```
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
```java
@Component
public class TwoService {
    @Autowired
    OneService oneService;

    public TwoService() {
        System.out.println("Construct TwoService");
    }

    public void getOneService(){
        System.out.println(oneService);
    }
}
```
```java
public class Test {
    public static void main(String[] args) {
        //初始化Spring容器
        AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);

        ac.getBean(OneService.class).getTwoService();
    }
}
```
这四个代码片段，即展示了Spring当中的循环依赖。
明白循环依赖，首先要明白依赖注入。
# Spring：依赖注入
依赖注入是在Spring容器初始化的时候完成的。这期间有一个过程：以上述代码为例，初始化`AnnotationConfigApplicationContext`容器，首先读取`MyConfig`类，扫描包下的Spring管理的注解的类，然后利用这些类的信息，进行bean的初始化。
初始化bean：1、2、3、4、5、6、...N步,分好多步，接下来，看一下这些具体的步骤。
## Spring bean的初始化
普通类的初始化，简单的来说，就是.java结尾的类，在经过编译后，生成.class字节码文件，然后jvm读取这些文件，将读取的类信息，放置到方法区，等到new的时候，利用这些信息，在堆空间开辟空间，产生一个对象。
而Spring bean的初始化，要经过更繁琐的过程。
### scan:
将扫描到的由Spring管理的类，生成类信息。
### parse：
接下来，Spring底层会解析这些类的信息，将一个一个的类，生成一个一个的`BeanDefinition`接口的实现类。
这些`BeanDefinition`类中，保存的是扫描到的类的信息，信息大致有：beanSocpe，扫描到的类是不是单例的？isLazy，扫描到的类是不是标注了`@Lazy`注解，是不是懒加载？不同的信息，Spring将做不同的策略。
### put map：
接下来，把这些`BeanDefinition`对象，放置到一个map中，map的key即扫描类的类名，value即`BeanDefinition`对象。
### 实例化：
接下来，将遍历这个map，然后实例化。实例化出的对象，依然放到新的map当中(`@Lazy`、原型，等特殊对象，此刻不会实例化。
#### Spring bean的生命周期
```java
public void refresh() throws BeansException, IllegalStateException {
        synchronized(this.startupShutdownMonitor) {
            StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");
            this.prepareRefresh();
            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
            this.prepareBeanFactory(beanFactory);

            try {
                this.postProcessBeanFactory(beanFactory);
                StartupStep beanPostProcess = this.applicationStartup.start("spring.context.beans.post-process");
                this.invokeBeanFactoryPostProcessors(beanFactory);
                this.registerBeanPostProcessors(beanFactory);
                beanPostProcess.end();
                this.initMessageSource();
                this.initApplicationEventMulticaster();
                this.onRefresh();
                this.registerListeners();
                this.finishBeanFactoryInitialization(beanFactory);
                this.finishRefresh();
            } catch (BeansException var10) {
                if (this.logger.isWarnEnabled()) {
                    this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var10);
                }

                this.destroyBeans();
                this.cancelRefresh(var10);
                throw var10;
            } finally {
                this.resetCommonCaches();
                contextRefresh.end();
            }

        }
    }
```
`this.invokeBeanFactoryPostProcessors(beanFactory);`此行完成了Spring bean的扫描，此刻，`BeanDefinition`对象已经全部加载到了map当中。
`this.finishBeanFactoryInitialization(beanFactory);`此行完成了实例化。
bean的生命周期，即在`this.finishBeanFactoryInitialization(beanFactory);`中。
进入此方法：
```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
        if (beanFactory.containsBean("conversionService") && beanFactory.isTypeMatch("conversionService", ConversionService.class)) {
            beanFactory.setConversionService((ConversionService)beanFactory.getBean("conversionService", ConversionService.class));
        }

        if (!beanFactory.hasEmbeddedValueResolver()) {
            beanFactory.addEmbeddedValueResolver((strVal) -> {
                return this.getEnvironment().resolvePlaceholders(strVal);
            });
        }

        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
        String[] var3 = weaverAwareNames;
        int var4 = weaverAwareNames.length;

        for(int var5 = 0; var5 < var4; ++var5) {
            String weaverAwareName = var3[var5];
            this.getBean(weaverAwareName);
        }

        beanFactory.setTempClassLoader((ClassLoader)null);
        beanFactory.freezeConfiguration();
        beanFactory.preInstantiateSingletons();
    }
```
`beanFactory.preInstantiateSingletons();`此行实例化所有的单例，非Lazy的。
进入此方法：
```java
public void preInstantiateSingletons() throws BeansException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Pre-instantiating singletons in " + this);
        }

        List<String> beanNames = new ArrayList(this.beanDefinitionNames);
        Iterator var2 = beanNames.iterator();

        while(true) {
            String beanName;
            Object bean;
            do {
                while(true) {
                    RootBeanDefinition bd;
                    do {
                        do {
                            do {
                                if (!var2.hasNext()) {
                                    var2 = beanNames.iterator();

                                    while(var2.hasNext()) {
                                        beanName = (String)var2.next();
                                        Object singletonInstance = this.getSingleton(beanName);
                                        if (singletonInstance instanceof SmartInitializingSingleton) {
                                            StartupStep smartInitialize = this.getApplicationStartup().start("spring.beans.smart-initialize").tag("beanName", beanName);
                                            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;
                                            if (System.getSecurityManager() != null) {
                                                AccessController.doPrivileged(() -> {
                                                    smartSingleton.afterSingletonsInstantiated();
                                                    return null;
                                                }, this.getAccessControlContext());
                                            } else {
                                                smartSingleton.afterSingletonsInstantiated();
                                            }

                                            smartInitialize.end();
                                        }
                                    }

                                    return;
                                }

                                beanName = (String)var2.next();
                                bd = this.getMergedLocalBeanDefinition(beanName);
                            } while(bd.isAbstract());
                        } while(!bd.isSingleton());
                    } while(bd.isLazyInit());

                    if (this.isFactoryBean(beanName)) {
                        bean = this.getBean("&" + beanName);
                        break;
                    }

                    this.getBean(beanName);
                }
            } while(!(bean instanceof FactoryBean));

            FactoryBean<?> factory = (FactoryBean)bean;
            boolean isEagerInit;
            if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                SmartFactoryBean var10000 = (SmartFactoryBean)factory;
                ((SmartFactoryBean)factory).getClass();
                isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, this.getAccessControlContext());
            } else {
                isEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean)factory).isEagerInit();
            }

            if (isEagerInit) {
                this.getBean(beanName);
            }
        }
    }
```
此方法，在遍历`BeanDefinition`对象，来验证这些`BeanDefinition`对象是不是可以将这些描述的bean实例化，因为有些非单例的bean，接下来不应该实例化的，所以有这么一个校验的过程。
接下来：进入此方法：`this.getBean(beanName);`
最核心的方法：
```java
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
        String beanName = this.transformedBeanName(name);
        Object sharedInstance = this.getSingleton(beanName);
        Object beanInstance;
        if (sharedInstance != null && args == null) {
            if (this.logger.isTraceEnabled()) {
                if (this.isSingletonCurrentlyInCreation(beanName)) {
                    this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
                } else {
                    this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
                }
            }

            beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
        } else {
            if (this.isPrototypeCurrentlyInCreation(beanName)) {
                throw new BeanCurrentlyInCreationException(beanName);
            }

            BeanFactory parentBeanFactory = this.getParentBeanFactory();
            if (parentBeanFactory != null && !this.containsBeanDefinition(beanName)) {
                String nameToLookup = this.originalBeanName(name);
                if (parentBeanFactory instanceof AbstractBeanFactory) {
                    return ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
                }

                if (args != null) {
                    return parentBeanFactory.getBean(nameToLookup, args);
                }

                if (requiredType != null) {
                    return parentBeanFactory.getBean(nameToLookup, requiredType);
                }

                return parentBeanFactory.getBean(nameToLookup);
            }

            if (!typeCheckOnly) {
                this.markBeanAsCreated(beanName);
            }

            StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate").tag("beanName", name);

            try {
                if (requiredType != null) {
                    beanCreation.tag("beanType", requiredType::toString);
                }

                RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);
                this.checkMergedBeanDefinition(mbd, beanName, args);
                String[] dependsOn = mbd.getDependsOn();
                String[] var12;
                if (dependsOn != null) {
                    var12 = dependsOn;
                    int var13 = dependsOn.length;

                    for(int var14 = 0; var14 < var13; ++var14) {
                        String dep = var12[var14];
                        if (this.isDependent(beanName, dep)) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                        }

                        this.registerDependentBean(dep, beanName);

                        try {
                            this.getBean(dep);
                        } catch (NoSuchBeanDefinitionException var31) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "'" + beanName + "' depends on missing bean '" + dep + "'", var31);
                        }
                    }
                }

                if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                } else if (mbd.isPrototype()) {
                    var12 = null;

                    Object prototypeInstance;
                    try {
                        this.beforePrototypeCreation(beanName);
                        prototypeInstance = this.createBean(beanName, mbd, args);
                    } finally {
                        this.afterPrototypeCreation(beanName);
                    }

                    beanInstance = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                } else {
                    String scopeName = mbd.getScope();
                    if (!StringUtils.hasLength(scopeName)) {
                        throw new IllegalStateException("No scope name defined for bean ��" + beanName + "'");
                    }

                    Scope scope = (Scope)this.scopes.get(scopeName);
                    if (scope == null) {
                        throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                    }

                    try {
                        Object scopedInstance = scope.get(beanName, () -> {
                            this.beforePrototypeCreation(beanName);

                            Object var4;
                            try {
                                var4 = this.createBean(beanName, mbd, args);
                            } finally {
                                this.afterPrototypeCreation(beanName);
                            }

                            return var4;
                        });
                        beanInstance = this.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                    } catch (IllegalStateException var30) {
                        throw new ScopeNotActiveException(beanName, scopeName, var30);
                    }
                }
            } catch (BeansException var32) {
                beanCreation.tag("exception", var32.getClass().toString());
                beanCreation.tag("message", String.valueOf(var32.getMessage()));
                this.cleanupAfterBeanCreationFailure(beanName);
                throw var32;
            } finally {
                beanCreation.end();
            }
        }

        return this.adaptBeanInstance(name, beanInstance, requiredType);
    }
```
`String beanName = this.transformedBeanName(name);`此行，先认为它是校验bean的名字是不是合法，其实还有很多其他作用；
`Object sharedInstance = this.getSingleton(beanName);`此行，是从一个map中尝试拿一下，这个bean，这个map是一个ConcurrentHashMap，是常说的Spring容器，但准确的应该叫Spring单例池，但此刻肯定是拿不到的，它为什么要拿一下呢?这里有个很关键的方法：`isSingletonCurrentlyInCreation(beanName)`
```java
String beanName = this.transformedBeanName(name);
Object sharedInstance = this.getSingleton(beanName);
Object beanInstance;
if (sharedInstance != null && args == null) {
    if (this.logger.isTraceEnabled()) {
        if (this.isSingletonCurrentlyInCreation(beanName)) {
            this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
        } else {
            this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
        }
    }

    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
}
```
至此，先跳过这部分。
再回到doGetBean方法：来到：
```java
if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }
```
此处，就要进行创建对象了：
```java
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Creating instance of bean '" + beanName + "'");
        }

        RootBeanDefinition mbdToUse = mbd;
        Class<?> resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
        if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
            mbdToUse = new RootBeanDefinition(mbd);
            mbdToUse.setBeanClass(resolvedClass);
        }

        try {
            mbdToUse.prepareMethodOverrides();
        } catch (BeanDefinitionValidationException var9) {
            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", var9);
        }

        Object beanInstance;
        try {
            beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);
            if (beanInstance != null) {
                return beanInstance;
            }
        } catch (Throwable var10) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", var10);
        }

        try {
            beanInstance = this.doCreateBean(beanName, mbdToUse, args);
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Finished creating instance of bean '" + beanName + "'");
            }

            return beanInstance;
        } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) {
            throw var7;
        } catch (Throwable var8) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", var8);
        }
    }
```
上面这段代码，可以看到，就是通过`BeanDefinition`对象拿到bean的Class类的对象出来，准备创建对象，就是拿到该类的构造器等信息，来实例化。虽然是实例化了，但并不是完整的Spring bean。如下代码片段
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    @PostConstruct
    public void aa(){
        //Spring bean生命周期初始化回调方法
        System.out.println("init");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
它这一步，仅仅是创建了OneService的基本对象，@Autowired，还有AOP功能，@PostConstruct等等都没有做，仅仅是new出来了这个基本对象。
在创建的过程中，进入doCreateBean方法中：
```java
//判断是否允许循环依赖
//主要就是this.allowCircularReferences,而Spring关闭默认允许循环依赖的关键也就是这里
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }

    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}
```
## 问题：怎么关闭Spring默认的允许循环依赖
1、直接修改源码，赋值allowCircularReferences属性为false。
2、手动refresh：
```java
//1、初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext(MyConfig.class);
//2、拿到beanFactory
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
//但这样其实没有用,因为1、步已经完成了容器的初始化。
```
正确的做法：
```java
//初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext();
//先调用默认构造器，然后自己来实现其构造器中的两个关键方法：register和refresh
ac.register(MyConfig.class);
//在此关闭循环依赖
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
ac.refresh();
```
回到创建过程：
```java
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }
    //在此进行第四次后置处理器，判断是否需要AOP
    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}

Object exposedObject = bean;

try {
    //填充属性，也就是常常说的自动注入
    //里面会完成第五次和第六次后置处理器的调用
    this.populateBean(beanName, mbd, instanceWrapper);
    //初始化bean
    //里面会完成第七次和第八次后置处理器的调用
    exposedObject = this.initializeBean(beanName, exposedObject, mbd);
} catch (Throwable var18) {
    if (var18 instanceof BeanCreationException && beanName.equals(((BeanCreationException)var18).getBeanName())) {
        throw (BeanCreationException)var18;
    }

    throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", var18);
}
```
进入populateBean方法：
```java
if (hasInstAwareBpps) {
    if (pvs == null) {
        pvs = mbd.getPropertyValues();
    }

    PropertyValues pvsToUse;
    for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {
        InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();
        pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
        if (pvsToUse == null) {
            if (filteredPds == null) {
                filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            }

            pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
                return;
            }
        }
    }
}
```
此行：`pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);`完成后，完成注入，比如TwoService，这时候就注入了进来。
注意，此处是个for循环，该循环在遍历后置处理器BeanPostProcessors，然后不同的BeanPostProcessor作不同的事情，比如常说的@Autowired注解，和@Resource注解的区别，这两个注解的组件走到这里的时候，会有不同的后置处理器来处理。
至此，来看开始循环注入的问题：
首先:初始化容器
```java
AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);
```
调用refresh方法：
```java
this.refresh();
```
经过：
```java
this.invokeBeanFactoryPostProcessors(beanFactory);
```
后完成扫描。
经过：
```java
this.finishBeanFactoryInitialization(beanFactory);
```
后完成bean的初始化。在：`this.finishBeanFactoryInitialization(beanFactory);`中，又进行了实例化所有的单例，非Lazy的bean：
```java
beanFactory.preInstantiateSingletons();
```
这里面，创建对象的过程是，先new出了基本的对象，然后接着进行属性填充：
```java
this.populateBean(beanName, mbd, instanceWrapper);
```
就是在此时，填充TwoService，这时候他会从容器中去拿TwoService这个bean，就是单例池中去拿，这时候肯定拿不到。
这时候就到了上面提到的：去池子中拿，拿不到，这时候有一个很关键的判断：
`if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName))`
```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
这个判断条件是不成立的。如果该条件成立，那么就要去三级缓存中拿。
# 循环依赖类的创建流程总结：
OK，循环依赖的两个类加载的过程：
调用构造方法new出OneService对象-->如果是单例，还会把自己放到一个代表正在创建中的Set集合中，如果开启了循环依赖，就会把当前的OneService的对象放到二级缓存中-->继续走，走到populateBean要进行填充TwoService-->从容器中找，这时候找不到。此刻就有上边这个判断，是不是正在创建的bean，如果此判断成功进入，就会从三级缓存中拿出来。-->拿不到，条件也没成立，这时候，就要new出TwoService来，当然此时new出的来TwoServcie对象，也要走bean的生命周期，那么它最终还是会走到populateBean这个方法，它也会去填充属性--->从容器中找OneService的bean，拿不到，所以它又要实例化一遍OneService，但这个过程中，但是此时有个判断条件却成立了，因为OneService确实是正在创建中，它从二级缓存中拿，是能拿到的，之前的过程存进去了。这时候，拿到OneService的对象，不等于null，就给TwoService注入了。
```java
/**
 * 比如第一次加载OneService,就会把自己放入二级缓存，当OneService进行到populateBean时，就会准备注入TwoService，
 * TwoService，也一样，最后进行到populateBean，从单例池中拿OneService，拿不到，继续从三级中拿，拿不到，继续从
 * 二级中拿，拿到了，就把OneService放进三级缓存，并将二级缓存中的移除。 
 */
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    //一级缓存：即单例池
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        //从三级缓存中拿 
        singletonObject = this.earlySingletonObjects.get(beanName);
        //如果拿不到
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        //从二级缓存中拿
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        //如果拿到了 
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            //放入三级缓存中
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            //将二级缓存中的移除
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
(String), 原创(String), 166(Integer), true(Boolean), true(Boolean), true(Boolean), true(Boolean), true(Boolean), 2021-04-03 01:26:55.386(Timestamp), 2021-04-04 23:40:56.51(Timestamp), 14(Long), 1(Long), 34(Long)
2021-04-25 19:09:35.623 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.updateById   : <==    Updates: 1
2021-04-25 19:09:35.658  INFO 19964 --- [http-nio-8080-exec-5] com.yi.blog.aspect.LogAspect             : Result:archivedetails
2021-04-25 19:10:27.095  INFO 19964 --- [http-nio-8080-exec-10] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/blog/34', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.blog', args=[34, {}]}
2021-04-25 19:10:27.107 DEBUG 19964 --- [http-nio-8080-exec-10] com.yi.blog.mapper.UserMapper.selectOne  : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE (id = ?) 
2021-04-25 19:10:27.107 DEBUG 19964 --- [http-nio-8080-exec-10] com.yi.blog.mapper.UserMapper.selectOne  : ==> Parameters: 1(Integer)
2021-04-25 19:10:27.118 DEBUG 19964 --- [http-nio-8080-exec-10] com.yi.blog.mapper.UserMapper.selectOne  : <==      Total: 1
2021-04-25 19:10:27.129 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.BlogMapper.selectById   : ==>  Preparing: SELECT id,title,content,first_picture,stamp,views,appreciate,original,comments,published,recommend,create_time,update_time,blog_type_id,user_id FROM blog WHERE id=? 
2021-04-25 19:10:27.129 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.BlogMapper.selectById   : ==> Parameters: 34(Long)
2021-04-25 19:10:27.154 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.BlogMapper.selectById   : <==      Total: 1
2021-04-25 19:10:27.154 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:10:27.155 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:10:27.165 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:10:27.168 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.BlogMapper.updateById   : ==>  Preparing: UPDATE blog SET title=?, content=?, stamp=?, views=?, appreciate=?, original=?, comments=?, published=?, recommend=?, create_time=?, update_time=?, blog_type_id=?, user_id=? WHERE id=? 
2021-04-25 19:10:27.169 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.BlogMapper.updateById   : ==> Parameters: Spring(一)(String), # Spring:循环依赖
## 什么是循环依赖?

```java
@ComponentScan("com.yi")
public class MyConfig {

}
```
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
```java
@Component
public class TwoService {
    @Autowired
    OneService oneService;

    public TwoService() {
        System.out.println("Construct TwoService");
    }

    public void getOneService(){
        System.out.println(oneService);
    }
}
```
```java
public class Test {
    public static void main(String[] args) {
        //初始化Spring容器
        AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);

        ac.getBean(OneService.class).getTwoService();
    }
}
```
这四个代码片段，即展示了Spring当中的循环依赖。
明白循环依赖，首先要明白依赖注入。
# Spring：依赖注入
依赖注入是在Spring容器初始化的时候完成的。这期间有一个过程：以上述代码为例，初始化`AnnotationConfigApplicationContext`容器，首先读取`MyConfig`类，扫描包下的Spring管理的注解的类，然后利用这些类的信息，进行bean的初始化。
初始化bean：1、2、3、4、5、6、...N步,分好多步，接下来，看一下这些具体的步骤。
## Spring bean的初始化
普通类的初始化，简单的来说，就是.java结尾的类，在经过编译后，生成.class字节码文件，然后jvm读取这些文件，将读取的类信息，放置到方法区，等到new的时候，利用这些信息，在堆空间开辟空间，产生一个对象。
而Spring bean的初始化，要经过更繁琐的过程。
### scan:
将扫描到的由Spring管理的类，生成类信息。
### parse：
接下来，Spring底层会解析这些类的信息，将一个一个的类，生成一个一个的`BeanDefinition`接口的实现类。
这些`BeanDefinition`类中，保存的是扫描到的类的信息，信息大致有：beanSocpe，扫描到的类是不是单例的？isLazy，扫描到的类是不是标注了`@Lazy`注解，是不是懒加载？不同的信息，Spring将做不同的策略。
### put map：
接下来，把这些`BeanDefinition`对象，放置到一个map中，map的key即扫描类的类名，value即`BeanDefinition`对象。
### 实例化：
接下来，将遍历这个map，然后实例化。实例化出的对象，依然放到新的map当中(`@Lazy`、原型，等特殊对象，此刻不会实例化。
#### Spring bean的生命周期
```java
public void refresh() throws BeansException, IllegalStateException {
        synchronized(this.startupShutdownMonitor) {
            StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");
            this.prepareRefresh();
            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
            this.prepareBeanFactory(beanFactory);

            try {
                this.postProcessBeanFactory(beanFactory);
                StartupStep beanPostProcess = this.applicationStartup.start("spring.context.beans.post-process");
                this.invokeBeanFactoryPostProcessors(beanFactory);
                this.registerBeanPostProcessors(beanFactory);
                beanPostProcess.end();
                this.initMessageSource();
                this.initApplicationEventMulticaster();
                this.onRefresh();
                this.registerListeners();
                this.finishBeanFactoryInitialization(beanFactory);
                this.finishRefresh();
            } catch (BeansException var10) {
                if (this.logger.isWarnEnabled()) {
                    this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var10);
                }

                this.destroyBeans();
                this.cancelRefresh(var10);
                throw var10;
            } finally {
                this.resetCommonCaches();
                contextRefresh.end();
            }

        }
    }
```
`this.invokeBeanFactoryPostProcessors(beanFactory);`此行完成了Spring bean的扫描，此刻，`BeanDefinition`对象已经全部加载到了map当中。
`this.finishBeanFactoryInitialization(beanFactory);`此行完成了实例化。
bean的生命周期，即在`this.finishBeanFactoryInitialization(beanFactory);`中。
进入此方法：
```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
        if (beanFactory.containsBean("conversionService") && beanFactory.isTypeMatch("conversionService", ConversionService.class)) {
            beanFactory.setConversionService((ConversionService)beanFactory.getBean("conversionService", ConversionService.class));
        }

        if (!beanFactory.hasEmbeddedValueResolver()) {
            beanFactory.addEmbeddedValueResolver((strVal) -> {
                return this.getEnvironment().resolvePlaceholders(strVal);
            });
        }

        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
        String[] var3 = weaverAwareNames;
        int var4 = weaverAwareNames.length;

        for(int var5 = 0; var5 < var4; ++var5) {
            String weaverAwareName = var3[var5];
            this.getBean(weaverAwareName);
        }

        beanFactory.setTempClassLoader((ClassLoader)null);
        beanFactory.freezeConfiguration();
        beanFactory.preInstantiateSingletons();
    }
```
`beanFactory.preInstantiateSingletons();`此行实例化所有的单例，非Lazy的。
进入此方法：
```java
public void preInstantiateSingletons() throws BeansException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Pre-instantiating singletons in " + this);
        }

        List<String> beanNames = new ArrayList(this.beanDefinitionNames);
        Iterator var2 = beanNames.iterator();

        while(true) {
            String beanName;
            Object bean;
            do {
                while(true) {
                    RootBeanDefinition bd;
                    do {
                        do {
                            do {
                                if (!var2.hasNext()) {
                                    var2 = beanNames.iterator();

                                    while(var2.hasNext()) {
                                        beanName = (String)var2.next();
                                        Object singletonInstance = this.getSingleton(beanName);
                                        if (singletonInstance instanceof SmartInitializingSingleton) {
                                            StartupStep smartInitialize = this.getApplicationStartup().start("spring.beans.smart-initialize").tag("beanName", beanName);
                                            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;
                                            if (System.getSecurityManager() != null) {
                                                AccessController.doPrivileged(() -> {
                                                    smartSingleton.afterSingletonsInstantiated();
                                                    return null;
                                                }, this.getAccessControlContext());
                                            } else {
                                                smartSingleton.afterSingletonsInstantiated();
                                            }

                                            smartInitialize.end();
                                        }
                                    }

                                    return;
                                }

                                beanName = (String)var2.next();
                                bd = this.getMergedLocalBeanDefinition(beanName);
                            } while(bd.isAbstract());
                        } while(!bd.isSingleton());
                    } while(bd.isLazyInit());

                    if (this.isFactoryBean(beanName)) {
                        bean = this.getBean("&" + beanName);
                        break;
                    }

                    this.getBean(beanName);
                }
            } while(!(bean instanceof FactoryBean));

            FactoryBean<?> factory = (FactoryBean)bean;
            boolean isEagerInit;
            if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                SmartFactoryBean var10000 = (SmartFactoryBean)factory;
                ((SmartFactoryBean)factory).getClass();
                isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, this.getAccessControlContext());
            } else {
                isEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean)factory).isEagerInit();
            }

            if (isEagerInit) {
                this.getBean(beanName);
            }
        }
    }
```
此方法，在遍历`BeanDefinition`对象，来验证这些`BeanDefinition`对象是不是可以将这些描述的bean实例化，因为有些非单例的bean，接下来不应该实例化的，所以有这么一个校验的过程。
接下来：进入此方法：`this.getBean(beanName);`
最核心的方法：
```java
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
        String beanName = this.transformedBeanName(name);
        Object sharedInstance = this.getSingleton(beanName);
        Object beanInstance;
        if (sharedInstance != null && args == null) {
            if (this.logger.isTraceEnabled()) {
                if (this.isSingletonCurrentlyInCreation(beanName)) {
                    this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
                } else {
                    this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
                }
            }

            beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
        } else {
            if (this.isPrototypeCurrentlyInCreation(beanName)) {
                throw new BeanCurrentlyInCreationException(beanName);
            }

            BeanFactory parentBeanFactory = this.getParentBeanFactory();
            if (parentBeanFactory != null && !this.containsBeanDefinition(beanName)) {
                String nameToLookup = this.originalBeanName(name);
                if (parentBeanFactory instanceof AbstractBeanFactory) {
                    return ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
                }

                if (args != null) {
                    return parentBeanFactory.getBean(nameToLookup, args);
                }

                if (requiredType != null) {
                    return parentBeanFactory.getBean(nameToLookup, requiredType);
                }

                return parentBeanFactory.getBean(nameToLookup);
            }

            if (!typeCheckOnly) {
                this.markBeanAsCreated(beanName);
            }

            StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate").tag("beanName", name);

            try {
                if (requiredType != null) {
                    beanCreation.tag("beanType", requiredType::toString);
                }

                RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);
                this.checkMergedBeanDefinition(mbd, beanName, args);
                String[] dependsOn = mbd.getDependsOn();
                String[] var12;
                if (dependsOn != null) {
                    var12 = dependsOn;
                    int var13 = dependsOn.length;

                    for(int var14 = 0; var14 < var13; ++var14) {
                        String dep = var12[var14];
                        if (this.isDependent(beanName, dep)) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                        }

                        this.registerDependentBean(dep, beanName);

                        try {
                            this.getBean(dep);
                        } catch (NoSuchBeanDefinitionException var31) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "'" + beanName + "' depends on missing bean '" + dep + "'", var31);
                        }
                    }
                }

                if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                } else if (mbd.isPrototype()) {
                    var12 = null;

                    Object prototypeInstance;
                    try {
                        this.beforePrototypeCreation(beanName);
                        prototypeInstance = this.createBean(beanName, mbd, args);
                    } finally {
                        this.afterPrototypeCreation(beanName);
                    }

                    beanInstance = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                } else {
                    String scopeName = mbd.getScope();
                    if (!StringUtils.hasLength(scopeName)) {
                        throw new IllegalStateException("No scope name defined for bean ��" + beanName + "'");
                    }

                    Scope scope = (Scope)this.scopes.get(scopeName);
                    if (scope == null) {
                        throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                    }

                    try {
                        Object scopedInstance = scope.get(beanName, () -> {
                            this.beforePrototypeCreation(beanName);

                            Object var4;
                            try {
                                var4 = this.createBean(beanName, mbd, args);
                            } finally {
                                this.afterPrototypeCreation(beanName);
                            }

                            return var4;
                        });
                        beanInstance = this.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                    } catch (IllegalStateException var30) {
                        throw new ScopeNotActiveException(beanName, scopeName, var30);
                    }
                }
            } catch (BeansException var32) {
                beanCreation.tag("exception", var32.getClass().toString());
                beanCreation.tag("message", String.valueOf(var32.getMessage()));
                this.cleanupAfterBeanCreationFailure(beanName);
                throw var32;
            } finally {
                beanCreation.end();
            }
        }

        return this.adaptBeanInstance(name, beanInstance, requiredType);
    }
```
`String beanName = this.transformedBeanName(name);`此行，先认为它是校验bean的名字是不是合法，其实还有很多其他作用；
`Object sharedInstance = this.getSingleton(beanName);`此行，是从一个map中尝试拿一下，这个bean，这个map是一个ConcurrentHashMap，是常说的Spring容器，但准确的应该叫Spring单例池，但此刻肯定是拿不到的，它为什么要拿一下呢?这里有个很关键的方法：`isSingletonCurrentlyInCreation(beanName)`
```java
String beanName = this.transformedBeanName(name);
Object sharedInstance = this.getSingleton(beanName);
Object beanInstance;
if (sharedInstance != null && args == null) {
    if (this.logger.isTraceEnabled()) {
        if (this.isSingletonCurrentlyInCreation(beanName)) {
            this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
        } else {
            this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
        }
    }

    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
}
```
至此，先跳过这部分。
再回到doGetBean方法：来到：
```java
if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }
```
此处，就要进行创建对象了：
```java
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Creating instance of bean '" + beanName + "'");
        }

        RootBeanDefinition mbdToUse = mbd;
        Class<?> resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
        if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
            mbdToUse = new RootBeanDefinition(mbd);
            mbdToUse.setBeanClass(resolvedClass);
        }

        try {
            mbdToUse.prepareMethodOverrides();
        } catch (BeanDefinitionValidationException var9) {
            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", var9);
        }

        Object beanInstance;
        try {
            beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);
            if (beanInstance != null) {
                return beanInstance;
            }
        } catch (Throwable var10) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", var10);
        }

        try {
            beanInstance = this.doCreateBean(beanName, mbdToUse, args);
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Finished creating instance of bean '" + beanName + "'");
            }

            return beanInstance;
        } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) {
            throw var7;
        } catch (Throwable var8) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", var8);
        }
    }
```
上面这段代码，可以看到，就是通过`BeanDefinition`对象拿到bean的Class类的对象出来，准备创建对象，就是拿到该类的构造器等信息，来实例化。虽然是实例化了，但并不是完整的Spring bean。如下代码片段
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    @PostConstruct
    public void aa(){
        //Spring bean生命周期初始化回调方法
        System.out.println("init");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
它这一步，仅仅是创建了OneService的基本对象，@Autowired，还有AOP功能，@PostConstruct等等都没有做，仅仅是new出来了这个基本对象。
在创建的过程中，进入doCreateBean方法中：
```java
//判断是否允许循环依赖
//主要就是this.allowCircularReferences,而Spring关闭默认允许循环依赖的关键也就是这里
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }

    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}
```
## 问题：怎么关闭Spring默认的允许循环依赖
1、直接修改源码，赋值allowCircularReferences属性为false。
2、手动refresh：
```java
//1、初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext(MyConfig.class);
//2、拿到beanFactory
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
//但这样其实没有用,因为1、步已经完成了容器的初始化。
```
正确的做法：
```java
//初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext();
//先调用默认构造器，然后自己来实现其构造器中的两个关键方法：register和refresh
ac.register(MyConfig.class);
//在此关闭循环依赖
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
ac.refresh();
```
回到创建过程：
```java
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }
    //在此进行第四次后置处理器，判断是否需要AOP
    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}

Object exposedObject = bean;

try {
    //填充属性，也就是常常说的自动注入
    //里面会完成第五次和第六次后置处理器的调用
    this.populateBean(beanName, mbd, instanceWrapper);
    //初始化bean
    //里面会完成第七次和第八次后置处理器的调用
    exposedObject = this.initializeBean(beanName, exposedObject, mbd);
} catch (Throwable var18) {
    if (var18 instanceof BeanCreationException && beanName.equals(((BeanCreationException)var18).getBeanName())) {
        throw (BeanCreationException)var18;
    }

    throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", var18);
}
```
进入populateBean方法：
```java
if (hasInstAwareBpps) {
    if (pvs == null) {
        pvs = mbd.getPropertyValues();
    }

    PropertyValues pvsToUse;
    for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {
        InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();
        pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
        if (pvsToUse == null) {
            if (filteredPds == null) {
                filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            }

            pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
                return;
            }
        }
    }
}
```
此行：`pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);`完成后，完成注入，比如TwoService，这时候就注入了进来。
注意，此处是个for循环，该循环在遍历后置处理器BeanPostProcessors，然后不同的BeanPostProcessor作不同的事情，比如常说的@Autowired注解，和@Resource注解的区别，这两个注解的组件走到这里的时候，会有不同的后置处理器来处理。
至此，来看开始循环注入的问题：
首先:初始化容器
```java
AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);
```
调用refresh方法：
```java
this.refresh();
```
经过：
```java
this.invokeBeanFactoryPostProcessors(beanFactory);
```
后完成扫描。
经过：
```java
this.finishBeanFactoryInitialization(beanFactory);
```
后完成bean的初始化。在：`this.finishBeanFactoryInitialization(beanFactory);`中，又进行了实例化所有的单例，非Lazy的bean：
```java
beanFactory.preInstantiateSingletons();
```
这里面，创建对象的过程是，先new出了基本的对象，然后接着进行属性填充：
```java
this.populateBean(beanName, mbd, instanceWrapper);
```
就是在此时，填充TwoService，这时候他会从容器中去拿TwoService这个bean，就是单例池中去拿，这时候肯定拿不到。
这时候就到了上面提到的：去池子中拿，拿不到，这时候有一个很关键的判断：
`if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName))`
```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
这个判断条件是不成立的。如果该条件成立，那么就要去三级缓存中拿。
# 循环依赖类的创建流程总结：
OK，循环依赖的两个类加载的过程：
调用构造方法new出OneService对象-->如果是单例，还会把自己放到一个代表正在创建中的Set集合中，如果开启了循环依赖，就会把当前的OneService的对象放到二级缓存中-->继续走，走到populateBean要进行填充TwoService-->从容器中找，这时候找不到。此刻就有上边这个判断，是不是正在创建的bean，如果此判断成功进入，就会从三级缓存中拿出来。-->拿不到，条件也没成立，这时候，就要new出TwoService来，当然此时new出的来TwoServcie对象，也要走bean的生命周期，那么它最终还是会走到populateBean这个方法，它也会去填充属性--->从容器中找OneService的bean，拿不到，所以它又要实例化一遍OneService，但这个过程中，但是此时有个判断条件却成立了，因为OneService确实是正在创建中，它从二级缓存中拿，是能拿到的，之前的过程存进去了。这时候，拿到OneService的对象，不等于null，就给TwoService注入了。
```java
/**
 * 比如第一次加载OneService,就会把自己放入二级缓存，当OneService进行到populateBean时，就会准备注入TwoService，
 * TwoService，也一样，最后进行到populateBean，从单例池中拿OneService，拿不到，继续从三级中拿，拿不到，继续从
 * 二级中拿，拿到了，就把OneService放进三级缓存，并将二级缓存中的移除。 
 */
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    //一级缓存：即单例池
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        //从三级缓存中拿 
        singletonObject = this.earlySingletonObjects.get(beanName);
        //如果拿不到
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        //从二级缓存中拿
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        //如果拿到了 
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            //放入三级缓存中
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            //将二级缓存中的移除
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
(String), 原创(String), 167(Integer), true(Boolean), true(Boolean), true(Boolean), true(Boolean), true(Boolean), 2021-04-03 01:26:55.386(Timestamp), 2021-04-04 23:40:56.51(Timestamp), 14(Long), 1(Long), 34(Long)
2021-04-25 19:10:27.193 DEBUG 19964 --- [http-nio-8080-exec-10] c.yi.blog.mapper.BlogMapper.updateById   : <==    Updates: 1
2021-04-25 19:10:27.228  INFO 19964 --- [http-nio-8080-exec-10] com.yi.blog.aspect.LogAspect             : Result:archivedetails
2021-04-25 19:11:40.478  INFO 19964 --- [http-nio-8080-exec-5] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/blog/34', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.blog', args=[34, {}]}
2021-04-25 19:11:40.488 DEBUG 19964 --- [http-nio-8080-exec-5] com.yi.blog.mapper.UserMapper.selectOne  : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE (id = ?) 
2021-04-25 19:11:40.489 DEBUG 19964 --- [http-nio-8080-exec-5] com.yi.blog.mapper.UserMapper.selectOne  : ==> Parameters: 1(Integer)
2021-04-25 19:11:40.500 DEBUG 19964 --- [http-nio-8080-exec-5] com.yi.blog.mapper.UserMapper.selectOne  : <==      Total: 1
2021-04-25 19:11:40.511 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.selectById   : ==>  Preparing: SELECT id,title,content,first_picture,stamp,views,appreciate,original,comments,published,recommend,create_time,update_time,blog_type_id,user_id FROM blog WHERE id=? 
2021-04-25 19:11:40.511 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.selectById   : ==> Parameters: 34(Long)
2021-04-25 19:11:40.535 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.selectById   : <==      Total: 1
2021-04-25 19:11:40.536 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:11:40.536 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:11:40.547 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:11:40.549 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.updateById   : ==>  Preparing: UPDATE blog SET title=?, content=?, stamp=?, views=?, appreciate=?, original=?, comments=?, published=?, recommend=?, create_time=?, update_time=?, blog_type_id=?, user_id=? WHERE id=? 
2021-04-25 19:11:40.550 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.updateById   : ==> Parameters: Spring(一)(String), # Spring:循环依赖
## 什么是循环依赖?

```java
@ComponentScan("com.yi")
public class MyConfig {

}
```
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
```java
@Component
public class TwoService {
    @Autowired
    OneService oneService;

    public TwoService() {
        System.out.println("Construct TwoService");
    }

    public void getOneService(){
        System.out.println(oneService);
    }
}
```
```java
public class Test {
    public static void main(String[] args) {
        //初始化Spring容器
        AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);

        ac.getBean(OneService.class).getTwoService();
    }
}
```
这四个代码片段，即展示了Spring当中的循环依赖。
明白循环依赖，首先要明白依赖注入。
# Spring：依赖注入
依赖注入是在Spring容器初始化的时候完成的。这期间有一个过程：以上述代码为例，初始化`AnnotationConfigApplicationContext`容器，首先读取`MyConfig`类，扫描包下的Spring管理的注解的类，然后利用这些类的信息，进行bean的初始化。
初始化bean：1、2、3、4、5、6、...N步,分好多步，接下来，看一下这些具体的步骤。
## Spring bean的初始化
普通类的初始化，简单的来说，就是.java结尾的类，在经过编译后，生成.class字节码文件，然后jvm读取这些文件，将读取的类信息，放置到方法区，等到new的时候，利用这些信息，在堆空间开辟空间，产生一个对象。
而Spring bean的初始化，要经过更繁琐的过程。
### scan:
将扫描到的由Spring管理的类，生成类信息。
### parse：
接下来，Spring底层会解析这些类的信息，将一个一个的类，生成一个一个的`BeanDefinition`接口的实现类。
这些`BeanDefinition`类中，保存的是扫描到的类的信息，信息大致有：beanSocpe，扫描到的类是不是单例的？isLazy，扫描到的类是不是标注了`@Lazy`注解，是不是懒加载？不同的信息，Spring将做不同的策略。
### put map：
接下来，把这些`BeanDefinition`对象，放置到一个map中，map的key即扫描类的类名，value即`BeanDefinition`对象。
### 实例化：
接下来，将遍历这个map，然后实例化。实例化出的对象，依然放到新的map当中(`@Lazy`、原型，等特殊对象，此刻不会实例化。
#### Spring bean的生命周期
```java
public void refresh() throws BeansException, IllegalStateException {
        synchronized(this.startupShutdownMonitor) {
            StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");
            this.prepareRefresh();
            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
            this.prepareBeanFactory(beanFactory);

            try {
                this.postProcessBeanFactory(beanFactory);
                StartupStep beanPostProcess = this.applicationStartup.start("spring.context.beans.post-process");
                this.invokeBeanFactoryPostProcessors(beanFactory);
                this.registerBeanPostProcessors(beanFactory);
                beanPostProcess.end();
                this.initMessageSource();
                this.initApplicationEventMulticaster();
                this.onRefresh();
                this.registerListeners();
                this.finishBeanFactoryInitialization(beanFactory);
                this.finishRefresh();
            } catch (BeansException var10) {
                if (this.logger.isWarnEnabled()) {
                    this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var10);
                }

                this.destroyBeans();
                this.cancelRefresh(var10);
                throw var10;
            } finally {
                this.resetCommonCaches();
                contextRefresh.end();
            }

        }
    }
```
`this.invokeBeanFactoryPostProcessors(beanFactory);`此行完成了Spring bean的扫描，此刻，`BeanDefinition`对象已经全部加载到了map当中。
`this.finishBeanFactoryInitialization(beanFactory);`此行完成了实例化。
bean的生命周期，即在`this.finishBeanFactoryInitialization(beanFactory);`中。
进入此方法：
```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
        if (beanFactory.containsBean("conversionService") && beanFactory.isTypeMatch("conversionService", ConversionService.class)) {
            beanFactory.setConversionService((ConversionService)beanFactory.getBean("conversionService", ConversionService.class));
        }

        if (!beanFactory.hasEmbeddedValueResolver()) {
            beanFactory.addEmbeddedValueResolver((strVal) -> {
                return this.getEnvironment().resolvePlaceholders(strVal);
            });
        }

        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
        String[] var3 = weaverAwareNames;
        int var4 = weaverAwareNames.length;

        for(int var5 = 0; var5 < var4; ++var5) {
            String weaverAwareName = var3[var5];
            this.getBean(weaverAwareName);
        }

        beanFactory.setTempClassLoader((ClassLoader)null);
        beanFactory.freezeConfiguration();
        beanFactory.preInstantiateSingletons();
    }
```
`beanFactory.preInstantiateSingletons();`此行实例化所有的单例，非Lazy的。
进入此方法：
```java
public void preInstantiateSingletons() throws BeansException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Pre-instantiating singletons in " + this);
        }

        List<String> beanNames = new ArrayList(this.beanDefinitionNames);
        Iterator var2 = beanNames.iterator();

        while(true) {
            String beanName;
            Object bean;
            do {
                while(true) {
                    RootBeanDefinition bd;
                    do {
                        do {
                            do {
                                if (!var2.hasNext()) {
                                    var2 = beanNames.iterator();

                                    while(var2.hasNext()) {
                                        beanName = (String)var2.next();
                                        Object singletonInstance = this.getSingleton(beanName);
                                        if (singletonInstance instanceof SmartInitializingSingleton) {
                                            StartupStep smartInitialize = this.getApplicationStartup().start("spring.beans.smart-initialize").tag("beanName", beanName);
                                            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;
                                            if (System.getSecurityManager() != null) {
                                                AccessController.doPrivileged(() -> {
                                                    smartSingleton.afterSingletonsInstantiated();
                                                    return null;
                                                }, this.getAccessControlContext());
                                            } else {
                                                smartSingleton.afterSingletonsInstantiated();
                                            }

                                            smartInitialize.end();
                                        }
                                    }

                                    return;
                                }

                                beanName = (String)var2.next();
                                bd = this.getMergedLocalBeanDefinition(beanName);
                            } while(bd.isAbstract());
                        } while(!bd.isSingleton());
                    } while(bd.isLazyInit());

                    if (this.isFactoryBean(beanName)) {
                        bean = this.getBean("&" + beanName);
                        break;
                    }

                    this.getBean(beanName);
                }
            } while(!(bean instanceof FactoryBean));

            FactoryBean<?> factory = (FactoryBean)bean;
            boolean isEagerInit;
            if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                SmartFactoryBean var10000 = (SmartFactoryBean)factory;
                ((SmartFactoryBean)factory).getClass();
                isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, this.getAccessControlContext());
            } else {
                isEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean)factory).isEagerInit();
            }

            if (isEagerInit) {
                this.getBean(beanName);
            }
        }
    }
```
此方法，在遍历`BeanDefinition`对象，来验证这些`BeanDefinition`对象是不是可以将这些描述的bean实例化，因为有些非单例的bean，接下来不应该实例化的，所以有这么一个校验的过程。
接下来：进入此方法：`this.getBean(beanName);`
最核心的方法：
```java
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
        String beanName = this.transformedBeanName(name);
        Object sharedInstance = this.getSingleton(beanName);
        Object beanInstance;
        if (sharedInstance != null && args == null) {
            if (this.logger.isTraceEnabled()) {
                if (this.isSingletonCurrentlyInCreation(beanName)) {
                    this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
                } else {
                    this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
                }
            }

            beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
        } else {
            if (this.isPrototypeCurrentlyInCreation(beanName)) {
                throw new BeanCurrentlyInCreationException(beanName);
            }

            BeanFactory parentBeanFactory = this.getParentBeanFactory();
            if (parentBeanFactory != null && !this.containsBeanDefinition(beanName)) {
                String nameToLookup = this.originalBeanName(name);
                if (parentBeanFactory instanceof AbstractBeanFactory) {
                    return ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
                }

                if (args != null) {
                    return parentBeanFactory.getBean(nameToLookup, args);
                }

                if (requiredType != null) {
                    return parentBeanFactory.getBean(nameToLookup, requiredType);
                }

                return parentBeanFactory.getBean(nameToLookup);
            }

            if (!typeCheckOnly) {
                this.markBeanAsCreated(beanName);
            }

            StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate").tag("beanName", name);

            try {
                if (requiredType != null) {
                    beanCreation.tag("beanType", requiredType::toString);
                }

                RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);
                this.checkMergedBeanDefinition(mbd, beanName, args);
                String[] dependsOn = mbd.getDependsOn();
                String[] var12;
                if (dependsOn != null) {
                    var12 = dependsOn;
                    int var13 = dependsOn.length;

                    for(int var14 = 0; var14 < var13; ++var14) {
                        String dep = var12[var14];
                        if (this.isDependent(beanName, dep)) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                        }

                        this.registerDependentBean(dep, beanName);

                        try {
                            this.getBean(dep);
                        } catch (NoSuchBeanDefinitionException var31) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "'" + beanName + "' depends on missing bean '" + dep + "'", var31);
                        }
                    }
                }

                if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                } else if (mbd.isPrototype()) {
                    var12 = null;

                    Object prototypeInstance;
                    try {
                        this.beforePrototypeCreation(beanName);
                        prototypeInstance = this.createBean(beanName, mbd, args);
                    } finally {
                        this.afterPrototypeCreation(beanName);
                    }

                    beanInstance = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                } else {
                    String scopeName = mbd.getScope();
                    if (!StringUtils.hasLength(scopeName)) {
                        throw new IllegalStateException("No scope name defined for bean ��" + beanName + "'");
                    }

                    Scope scope = (Scope)this.scopes.get(scopeName);
                    if (scope == null) {
                        throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                    }

                    try {
                        Object scopedInstance = scope.get(beanName, () -> {
                            this.beforePrototypeCreation(beanName);

                            Object var4;
                            try {
                                var4 = this.createBean(beanName, mbd, args);
                            } finally {
                                this.afterPrototypeCreation(beanName);
                            }

                            return var4;
                        });
                        beanInstance = this.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                    } catch (IllegalStateException var30) {
                        throw new ScopeNotActiveException(beanName, scopeName, var30);
                    }
                }
            } catch (BeansException var32) {
                beanCreation.tag("exception", var32.getClass().toString());
                beanCreation.tag("message", String.valueOf(var32.getMessage()));
                this.cleanupAfterBeanCreationFailure(beanName);
                throw var32;
            } finally {
                beanCreation.end();
            }
        }

        return this.adaptBeanInstance(name, beanInstance, requiredType);
    }
```
`String beanName = this.transformedBeanName(name);`此行，先认为它是校验bean的名字是不是合法，其实还有很多其他作用；
`Object sharedInstance = this.getSingleton(beanName);`此行，是从一个map中尝试拿一下，这个bean，这个map是一个ConcurrentHashMap，是常说的Spring容器，但准确的应该叫Spring单例池，但此刻肯定是拿不到的，它为什么要拿一下呢?这里有个很关键的方法：`isSingletonCurrentlyInCreation(beanName)`
```java
String beanName = this.transformedBeanName(name);
Object sharedInstance = this.getSingleton(beanName);
Object beanInstance;
if (sharedInstance != null && args == null) {
    if (this.logger.isTraceEnabled()) {
        if (this.isSingletonCurrentlyInCreation(beanName)) {
            this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
        } else {
            this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
        }
    }

    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
}
```
至此，先跳过这部分。
再回到doGetBean方法：来到：
```java
if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }
```
此处，就要进行创建对象了：
```java
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Creating instance of bean '" + beanName + "'");
        }

        RootBeanDefinition mbdToUse = mbd;
        Class<?> resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
        if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
            mbdToUse = new RootBeanDefinition(mbd);
            mbdToUse.setBeanClass(resolvedClass);
        }

        try {
            mbdToUse.prepareMethodOverrides();
        } catch (BeanDefinitionValidationException var9) {
            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", var9);
        }

        Object beanInstance;
        try {
            beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);
            if (beanInstance != null) {
                return beanInstance;
            }
        } catch (Throwable var10) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", var10);
        }

        try {
            beanInstance = this.doCreateBean(beanName, mbdToUse, args);
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Finished creating instance of bean '" + beanName + "'");
            }

            return beanInstance;
        } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) {
            throw var7;
        } catch (Throwable var8) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", var8);
        }
    }
```
上面这段代码，可以看到，就是通过`BeanDefinition`对象拿到bean的Class类的对象出来，准备创建对象，就是拿到该类的构造器等信息，来实例化。虽然是实例化了，但并不是完整的Spring bean。如下代码片段
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    @PostConstruct
    public void aa(){
        //Spring bean生命周期初始化回调方法
        System.out.println("init");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
它这一步，仅仅是创建了OneService的基本对象，@Autowired，还有AOP功能，@PostConstruct等等都没有做，仅仅是new出来了这个基本对象。
在创建的过程中，进入doCreateBean方法中：
```java
//判断是否允许循环依赖
//主要就是this.allowCircularReferences,而Spring关闭默认允许循环依赖的关键也就是这里
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }

    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}
```
## 问题：怎么关闭Spring默认的允许循环依赖
1、直接修改源码，赋值allowCircularReferences属性为false。
2、手动refresh：
```java
//1、初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext(MyConfig.class);
//2、拿到beanFactory
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
//但这样其实没有用,因为1、步已经完成了容器的初始化。
```
正确的做法：
```java
//初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext();
//先调用默认构造器，然后自己来实现其构造器中的两个关键方法：register和refresh
ac.register(MyConfig.class);
//在此关闭循环依赖
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
ac.refresh();
```
回到创建过程：
```java
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }
    //在此进行第四次后置处理器，判断是否需要AOP
    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}

Object exposedObject = bean;

try {
    //填充属性，也就是常常说的自动注入
    //里面会完成第五次和第六次后置处理器的调用
    this.populateBean(beanName, mbd, instanceWrapper);
    //初始化bean
    //里面会完成第七次和第八次后置处理器的调用
    exposedObject = this.initializeBean(beanName, exposedObject, mbd);
} catch (Throwable var18) {
    if (var18 instanceof BeanCreationException && beanName.equals(((BeanCreationException)var18).getBeanName())) {
        throw (BeanCreationException)var18;
    }

    throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", var18);
}
```
进入populateBean方法：
```java
if (hasInstAwareBpps) {
    if (pvs == null) {
        pvs = mbd.getPropertyValues();
    }

    PropertyValues pvsToUse;
    for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {
        InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();
        pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
        if (pvsToUse == null) {
            if (filteredPds == null) {
                filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            }

            pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
                return;
            }
        }
    }
}
```
此行：`pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);`完成后，完成注入，比如TwoService，这时候就注入了进来。
注意，此处是个for循环，该循环在遍历后置处理器BeanPostProcessors，然后不同的BeanPostProcessor作不同的事情，比如常说的@Autowired注解，和@Resource注解的区别，这两个注解的组件走到这里的时候，会有不同的后置处理器来处理。
至此，来看开始循环注入的问题：
首先:初始化容器
```java
AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);
```
调用refresh方法：
```java
this.refresh();
```
经过：
```java
this.invokeBeanFactoryPostProcessors(beanFactory);
```
后完成扫描。
经过：
```java
this.finishBeanFactoryInitialization(beanFactory);
```
后完成bean的初始化。在：`this.finishBeanFactoryInitialization(beanFactory);`中，又进行了实例化所有的单例，非Lazy的bean：
```java
beanFactory.preInstantiateSingletons();
```
这里面，创建对象的过程是，先new出了基本的对象，然后接着进行属性填充：
```java
this.populateBean(beanName, mbd, instanceWrapper);
```
就是在此时，填充TwoService，这时候他会从容器中去拿TwoService这个bean，就是单例池中去拿，这时候肯定拿不到。
这时候就到了上面提到的：去池子中拿，拿不到，这时候有一个很关键的判断：
`if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName))`
```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
这个判断条件是不成立的。如果该条件成立，那么就要去三级缓存中拿。
# 循环依赖类的创建流程总结：
OK，循环依赖的两个类加载的过程：
调用构造方法new出OneService对象-->如果是单例，还会把自己放到一个代表正在创建中的Set集合中，如果开启了循环依赖，就会把当前的OneService的对象放到二级缓存中-->继续走，走到populateBean要进行填充TwoService-->从容器中找，这时候找不到。此刻就有上边这个判断，是不是正在创建的bean，如果此判断成功进入，就会从三级缓存中拿出来。-->拿不到，条件也没成立，这时候，就要new出TwoService来，当然此时new出的来TwoServcie对象，也要走bean的生命周期，那么它最终还是会走到populateBean这个方法，它也会去填充属性--->从容器中找OneService的bean，拿不到，所以它又要实例化一遍OneService，但这个过程中，但是此时有个判断条件却成立了，因为OneService确实是正在创建中，它从二级缓存中拿，是能拿到的，之前的过程存进去了。这时候，拿到OneService的对象，不等于null，就给TwoService注入了。
```java
/**
 * 比如第一次加载OneService,就会把自己放入二级缓存，当OneService进行到populateBean时，就会准备注入TwoService，
 * TwoService，也一样，最后进行到populateBean，从单例池中拿OneService，拿不到，继续从三级中拿，拿不到，继续从
 * 二级中拿，拿到了，就把OneService放进三级缓存，并将二级缓存中的移除。 
 */
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    //一级缓存：即单例池
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        //从三级缓存中拿 
        singletonObject = this.earlySingletonObjects.get(beanName);
        //如果拿不到
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        //从二级缓存中拿
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        //如果拿到了 
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            //放入三级缓存中
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            //将二级缓存中的移除
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
(String), 原创(String), 168(Integer), true(Boolean), true(Boolean), true(Boolean), true(Boolean), true(Boolean), 2021-04-03 01:26:55.386(Timestamp), 2021-04-04 23:40:56.51(Timestamp), 14(Long), 1(Long), 34(Long)
2021-04-25 19:11:40.573 DEBUG 19964 --- [http-nio-8080-exec-5] c.yi.blog.mapper.BlogMapper.updateById   : <==    Updates: 1
2021-04-25 19:11:40.606  INFO 19964 --- [http-nio-8080-exec-5] com.yi.blog.aspect.LogAspect             : Result:archivedetails
2021-04-25 19:12:13.675  INFO 19964 --- [http-nio-8080-exec-1] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/blog/34', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.blog', args=[34, {}]}
2021-04-25 19:12:13.687 DEBUG 19964 --- [http-nio-8080-exec-1] com.yi.blog.mapper.UserMapper.selectOne  : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE (id = ?) 
2021-04-25 19:12:13.687 DEBUG 19964 --- [http-nio-8080-exec-1] com.yi.blog.mapper.UserMapper.selectOne  : ==> Parameters: 1(Integer)
2021-04-25 19:12:13.697 DEBUG 19964 --- [http-nio-8080-exec-1] com.yi.blog.mapper.UserMapper.selectOne  : <==      Total: 1
2021-04-25 19:12:13.708 DEBUG 19964 --- [http-nio-8080-exec-1] c.yi.blog.mapper.BlogMapper.selectById   : ==>  Preparing: SELECT id,title,content,first_picture,stamp,views,appreciate,original,comments,published,recommend,create_time,update_time,blog_type_id,user_id FROM blog WHERE id=? 
2021-04-25 19:12:13.709 DEBUG 19964 --- [http-nio-8080-exec-1] c.yi.blog.mapper.BlogMapper.selectById   : ==> Parameters: 34(Long)
2021-04-25 19:12:13.732 DEBUG 19964 --- [http-nio-8080-exec-1] c.yi.blog.mapper.BlogMapper.selectById   : <==      Total: 1
2021-04-25 19:12:13.732 DEBUG 19964 --- [http-nio-8080-exec-1] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:12:13.733 DEBUG 19964 --- [http-nio-8080-exec-1] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:12:13.743 DEBUG 19964 --- [http-nio-8080-exec-1] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:12:13.744 DEBUG 19964 --- [http-nio-8080-exec-1] c.yi.blog.mapper.BlogMapper.updateById   : ==>  Preparing: UPDATE blog SET title=?, content=?, stamp=?, views=?, appreciate=?, original=?, comments=?, published=?, recommend=?, create_time=?, update_time=?, blog_type_id=?, user_id=? WHERE id=? 
2021-04-25 19:12:13.745 DEBUG 19964 --- [http-nio-8080-exec-1] c.yi.blog.mapper.BlogMapper.updateById   : ==> Parameters: Spring(一)(String), # Spring:循环依赖
## 什么是循环依赖?

```java
@ComponentScan("com.yi")
public class MyConfig {

}
```
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
```java
@Component
public class TwoService {
    @Autowired
    OneService oneService;

    public TwoService() {
        System.out.println("Construct TwoService");
    }

    public void getOneService(){
        System.out.println(oneService);
    }
}
```
```java
public class Test {
    public static void main(String[] args) {
        //初始化Spring容器
        AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);

        ac.getBean(OneService.class).getTwoService();
    }
}
```
这四个代码片段，即展示了Spring当中的循环依赖。
明白循环依赖，首先要明白依赖注入。
# Spring：依赖注入
依赖注入是在Spring容器初始化的时候完成的。这期间有一个过程：以上述代码为例，初始化`AnnotationConfigApplicationContext`容器，首先读取`MyConfig`类，扫描包下的Spring管理的注解的类，然后利用这些类的信息，进行bean的初始化。
初始化bean：1、2、3、4、5、6、...N步,分好多步，接下来，看一下这些具体的步骤。
## Spring bean的初始化
普通类的初始化，简单的来说，就是.java结尾的类，在经过编译后，生成.class字节码文件，然后jvm读取这些文件，将读取的类信息，放置到方法区，等到new的时候，利用这些信息，在堆空间开辟空间，产生一个对象。
而Spring bean的初始化，要经过更繁琐的过程。
### scan:
将扫描到的由Spring管理的类，生成类信息。
### parse：
接下来，Spring底层会解析这些类的信息，将一个一个的类，生成一个一个的`BeanDefinition`接口的实现类。
这些`BeanDefinition`类中，保存的是扫描到的类的信息，信息大致有：beanSocpe，扫描到的类是不是单例的？isLazy，扫描到的类是不是标注了`@Lazy`注解，是不是懒加载？不同的信息，Spring将做不同的策略。
### put map：
接下来，把这些`BeanDefinition`对象，放置到一个map中，map的key即扫描类的类名，value即`BeanDefinition`对象。
### 实例化：
接下来，将遍历这个map，然后实例化。实例化出的对象，依然放到新的map当中(`@Lazy`、原型，等特殊对象，此刻不会实例化。
#### Spring bean的生命周期
```java
public void refresh() throws BeansException, IllegalStateException {
        synchronized(this.startupShutdownMonitor) {
            StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");
            this.prepareRefresh();
            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
            this.prepareBeanFactory(beanFactory);

            try {
                this.postProcessBeanFactory(beanFactory);
                StartupStep beanPostProcess = this.applicationStartup.start("spring.context.beans.post-process");
                this.invokeBeanFactoryPostProcessors(beanFactory);
                this.registerBeanPostProcessors(beanFactory);
                beanPostProcess.end();
                this.initMessageSource();
                this.initApplicationEventMulticaster();
                this.onRefresh();
                this.registerListeners();
                this.finishBeanFactoryInitialization(beanFactory);
                this.finishRefresh();
            } catch (BeansException var10) {
                if (this.logger.isWarnEnabled()) {
                    this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var10);
                }

                this.destroyBeans();
                this.cancelRefresh(var10);
                throw var10;
            } finally {
                this.resetCommonCaches();
                contextRefresh.end();
            }

        }
    }
```
`this.invokeBeanFactoryPostProcessors(beanFactory);`此行完成了Spring bean的扫描，此刻，`BeanDefinition`对象已经全部加载到了map当中。
`this.finishBeanFactoryInitialization(beanFactory);`此行完成了实例化。
bean的生命周期，即在`this.finishBeanFactoryInitialization(beanFactory);`中。
进入此方法：
```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
        if (beanFactory.containsBean("conversionService") && beanFactory.isTypeMatch("conversionService", ConversionService.class)) {
            beanFactory.setConversionService((ConversionService)beanFactory.getBean("conversionService", ConversionService.class));
        }

        if (!beanFactory.hasEmbeddedValueResolver()) {
            beanFactory.addEmbeddedValueResolver((strVal) -> {
                return this.getEnvironment().resolvePlaceholders(strVal);
            });
        }

        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
        String[] var3 = weaverAwareNames;
        int var4 = weaverAwareNames.length;

        for(int var5 = 0; var5 < var4; ++var5) {
            String weaverAwareName = var3[var5];
            this.getBean(weaverAwareName);
        }

        beanFactory.setTempClassLoader((ClassLoader)null);
        beanFactory.freezeConfiguration();
        beanFactory.preInstantiateSingletons();
    }
```
`beanFactory.preInstantiateSingletons();`此行实例化所有的单例，非Lazy的。
进入此方法：
```java
public void preInstantiateSingletons() throws BeansException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Pre-instantiating singletons in " + this);
        }

        List<String> beanNames = new ArrayList(this.beanDefinitionNames);
        Iterator var2 = beanNames.iterator();

        while(true) {
            String beanName;
            Object bean;
            do {
                while(true) {
                    RootBeanDefinition bd;
                    do {
                        do {
                            do {
                                if (!var2.hasNext()) {
                                    var2 = beanNames.iterator();

                                    while(var2.hasNext()) {
                                        beanName = (String)var2.next();
                                        Object singletonInstance = this.getSingleton(beanName);
                                        if (singletonInstance instanceof SmartInitializingSingleton) {
                                            StartupStep smartInitialize = this.getApplicationStartup().start("spring.beans.smart-initialize").tag("beanName", beanName);
                                            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;
                                            if (System.getSecurityManager() != null) {
                                                AccessController.doPrivileged(() -> {
                                                    smartSingleton.afterSingletonsInstantiated();
                                                    return null;
                                                }, this.getAccessControlContext());
                                            } else {
                                                smartSingleton.afterSingletonsInstantiated();
                                            }

                                            smartInitialize.end();
                                        }
                                    }

                                    return;
                                }

                                beanName = (String)var2.next();
                                bd = this.getMergedLocalBeanDefinition(beanName);
                            } while(bd.isAbstract());
                        } while(!bd.isSingleton());
                    } while(bd.isLazyInit());

                    if (this.isFactoryBean(beanName)) {
                        bean = this.getBean("&" + beanName);
                        break;
                    }

                    this.getBean(beanName);
                }
            } while(!(bean instanceof FactoryBean));

            FactoryBean<?> factory = (FactoryBean)bean;
            boolean isEagerInit;
            if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                SmartFactoryBean var10000 = (SmartFactoryBean)factory;
                ((SmartFactoryBean)factory).getClass();
                isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, this.getAccessControlContext());
            } else {
                isEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean)factory).isEagerInit();
            }

            if (isEagerInit) {
                this.getBean(beanName);
            }
        }
    }
```
此方法，在遍历`BeanDefinition`对象，来验证这些`BeanDefinition`对象是不是可以将这些描述的bean实例化，因为有些非单例的bean，接下来不应该实例化的，所以有这么一个校验的过程。
接下来：进入此方法：`this.getBean(beanName);`
最核心的方法：
```java
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
        String beanName = this.transformedBeanName(name);
        Object sharedInstance = this.getSingleton(beanName);
        Object beanInstance;
        if (sharedInstance != null && args == null) {
            if (this.logger.isTraceEnabled()) {
                if (this.isSingletonCurrentlyInCreation(beanName)) {
                    this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
                } else {
                    this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
                }
            }

            beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
        } else {
            if (this.isPrototypeCurrentlyInCreation(beanName)) {
                throw new BeanCurrentlyInCreationException(beanName);
            }

            BeanFactory parentBeanFactory = this.getParentBeanFactory();
            if (parentBeanFactory != null && !this.containsBeanDefinition(beanName)) {
                String nameToLookup = this.originalBeanName(name);
                if (parentBeanFactory instanceof AbstractBeanFactory) {
                    return ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
                }

                if (args != null) {
                    return parentBeanFactory.getBean(nameToLookup, args);
                }

                if (requiredType != null) {
                    return parentBeanFactory.getBean(nameToLookup, requiredType);
                }

                return parentBeanFactory.getBean(nameToLookup);
            }

            if (!typeCheckOnly) {
                this.markBeanAsCreated(beanName);
            }

            StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate").tag("beanName", name);

            try {
                if (requiredType != null) {
                    beanCreation.tag("beanType", requiredType::toString);
                }

                RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);
                this.checkMergedBeanDefinition(mbd, beanName, args);
                String[] dependsOn = mbd.getDependsOn();
                String[] var12;
                if (dependsOn != null) {
                    var12 = dependsOn;
                    int var13 = dependsOn.length;

                    for(int var14 = 0; var14 < var13; ++var14) {
                        String dep = var12[var14];
                        if (this.isDependent(beanName, dep)) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                        }

                        this.registerDependentBean(dep, beanName);

                        try {
                            this.getBean(dep);
                        } catch (NoSuchBeanDefinitionException var31) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "'" + beanName + "' depends on missing bean '" + dep + "'", var31);
                        }
                    }
                }

                if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                } else if (mbd.isPrototype()) {
                    var12 = null;

                    Object prototypeInstance;
                    try {
                        this.beforePrototypeCreation(beanName);
                        prototypeInstance = this.createBean(beanName, mbd, args);
                    } finally {
                        this.afterPrototypeCreation(beanName);
                    }

                    beanInstance = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                } else {
                    String scopeName = mbd.getScope();
                    if (!StringUtils.hasLength(scopeName)) {
                        throw new IllegalStateException("No scope name defined for bean ��" + beanName + "'");
                    }

                    Scope scope = (Scope)this.scopes.get(scopeName);
                    if (scope == null) {
                        throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                    }

                    try {
                        Object scopedInstance = scope.get(beanName, () -> {
                            this.beforePrototypeCreation(beanName);

                            Object var4;
                            try {
                                var4 = this.createBean(beanName, mbd, args);
                            } finally {
                                this.afterPrototypeCreation(beanName);
                            }

                            return var4;
                        });
                        beanInstance = this.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                    } catch (IllegalStateException var30) {
                        throw new ScopeNotActiveException(beanName, scopeName, var30);
                    }
                }
            } catch (BeansException var32) {
                beanCreation.tag("exception", var32.getClass().toString());
                beanCreation.tag("message", String.valueOf(var32.getMessage()));
                this.cleanupAfterBeanCreationFailure(beanName);
                throw var32;
            } finally {
                beanCreation.end();
            }
        }

        return this.adaptBeanInstance(name, beanInstance, requiredType);
    }
```
`String beanName = this.transformedBeanName(name);`此行，先认为它是校验bean的名字是不是合法，其实还有很多其他作用；
`Object sharedInstance = this.getSingleton(beanName);`此行，是从一个map中尝试拿一下，这个bean，这个map是一个ConcurrentHashMap，是常说的Spring容器，但准确的应该叫Spring单例池，但此刻肯定是拿不到的，它为什么要拿一下呢?这里有个很关键的方法：`isSingletonCurrentlyInCreation(beanName)`
```java
String beanName = this.transformedBeanName(name);
Object sharedInstance = this.getSingleton(beanName);
Object beanInstance;
if (sharedInstance != null && args == null) {
    if (this.logger.isTraceEnabled()) {
        if (this.isSingletonCurrentlyInCreation(beanName)) {
            this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
        } else {
            this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
        }
    }

    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
}
```
至此，先跳过这部分。
再回到doGetBean方法：来到：
```java
if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }
```
此处，就要进行创建对象了：
```java
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Creating instance of bean '" + beanName + "'");
        }

        RootBeanDefinition mbdToUse = mbd;
        Class<?> resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
        if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
            mbdToUse = new RootBeanDefinition(mbd);
            mbdToUse.setBeanClass(resolvedClass);
        }

        try {
            mbdToUse.prepareMethodOverrides();
        } catch (BeanDefinitionValidationException var9) {
            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", var9);
        }

        Object beanInstance;
        try {
            beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);
            if (beanInstance != null) {
                return beanInstance;
            }
        } catch (Throwable var10) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", var10);
        }

        try {
            beanInstance = this.doCreateBean(beanName, mbdToUse, args);
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Finished creating instance of bean '" + beanName + "'");
            }

            return beanInstance;
        } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) {
            throw var7;
        } catch (Throwable var8) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", var8);
        }
    }
```
上面这段代码，可以看到，就是通过`BeanDefinition`对象拿到bean的Class类的对象出来，准备创建对象，就是拿到该类的构造器等信息，来实例化。虽然是实例化了，但并不是完整的Spring bean。如下代码片段
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    @PostConstruct
    public void aa(){
        //Spring bean生命周期初始化回调方法
        System.out.println("init");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
它这一步，仅仅是创建了OneService的基本对象，@Autowired，还有AOP功能，@PostConstruct等等都没有做，仅仅是new出来了这个基本对象。
在创建的过程中，进入doCreateBean方法中：
```java
//判断是否允许循环依赖
//主要就是this.allowCircularReferences,而Spring关闭默认允许循环依赖的关键也就是这里
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }

    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}
```
## 问题：怎么关闭Spring默认的允许循环依赖
1、直接修改源码，赋值allowCircularReferences属性为false。
2、手动refresh：
```java
//1、初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext(MyConfig.class);
//2、拿到beanFactory
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
//但这样其实没有用,因为1、步已经完成了容器的初始化。
```
正确的做法：
```java
//初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext();
//先调用默认构造器，然后自己来实现其构造器中的两个关键方法：register和refresh
ac.register(MyConfig.class);
//在此关闭循环依赖
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
ac.refresh();
```
回到创建过程：
```java
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }
    //在此进行第四次后置处理器，判断是否需要AOP
    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}

Object exposedObject = bean;

try {
    //填充属性，也就是常常说的自动注入
    //里面会完成第五次和第六次后置处理器的调用
    this.populateBean(beanName, mbd, instanceWrapper);
    //初始化bean
    //里面会完成第七次和第八次后置处理器的调用
    exposedObject = this.initializeBean(beanName, exposedObject, mbd);
} catch (Throwable var18) {
    if (var18 instanceof BeanCreationException && beanName.equals(((BeanCreationException)var18).getBeanName())) {
        throw (BeanCreationException)var18;
    }

    throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", var18);
}
```
进入populateBean方法：
```java
if (hasInstAwareBpps) {
    if (pvs == null) {
        pvs = mbd.getPropertyValues();
    }

    PropertyValues pvsToUse;
    for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {
        InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();
        pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
        if (pvsToUse == null) {
            if (filteredPds == null) {
                filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            }

            pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
                return;
            }
        }
    }
}
```
此行：`pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);`完成后，完成注入，比如TwoService，这时候就注入了进来。
注意，此处是个for循环，该循环在遍历后置处理器BeanPostProcessors，然后不同的BeanPostProcessor作不同的事情，比如常说的@Autowired注解，和@Resource注解的区别，这两个注解的组件走到这里的时候，会有不同的后置处理器来处理。
至此，来看开始循环注入的问题：
首先:初始化容器
```java
AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);
```
调用refresh方法：
```java
this.refresh();
```
经过：
```java
this.invokeBeanFactoryPostProcessors(beanFactory);
```
后完成扫描。
经过：
```java
this.finishBeanFactoryInitialization(beanFactory);
```
后完成bean的初始化。在：`this.finishBeanFactoryInitialization(beanFactory);`中，又进行了实例化所有的单例，非Lazy的bean：
```java
beanFactory.preInstantiateSingletons();
```
这里面，创建对象的过程是，先new出了基本的对象，然后接着进行属性填充：
```java
this.populateBean(beanName, mbd, instanceWrapper);
```
就是在此时，填充TwoService，这时候他会从容器中去拿TwoService这个bean，就是单例池中去拿，这时候肯定拿不到。
这时候就到了上面提到的：去池子中拿，拿不到，这时候有一个很关键的判断：
`if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName))`
```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
这个判断条件是不成立的。如果该条件成立，那么就要去三级缓存中拿。
# 循环依赖类的创建流程总结：
OK，循环依赖的两个类加载的过程：
调用构造方法new出OneService对象-->如果是单例，还会把自己放到一个代表正在创建中的Set集合中，如果开启了循环依赖，就会把当前的OneService的对象放到二级缓存中-->继续走，走到populateBean要进行填充TwoService-->从容器中找，这时候找不到。此刻就有上边这个判断，是不是正在创建的bean，如果此判断成功进入，就会从三级缓存中拿出来。-->拿不到，条件也没成立，这时候，就要new出TwoService来，当然此时new出的来TwoServcie对象，也要走bean的生命周期，那么它最终还是会走到populateBean这个方法，它也会去填充属性--->从容器中找OneService的bean，拿不到，所以它又要实例化一遍OneService，但这个过程中，但是此时有个判断条件却成立了，因为OneService确实是正在创建中，它从二级缓存中拿，是能拿到的，之前的过程存进去了。这时候，拿到OneService的对象，不等于null，就给TwoService注入了。
```java
/**
 * 比如第一次加载OneService,就会把自己放入二级缓存，当OneService进行到populateBean时，就会准备注入TwoService，
 * TwoService，也一样，最后进行到populateBean，从单例池中拿OneService，拿不到，继续从三级中拿，拿不到，继续从
 * 二级中拿，拿到了，就把OneService放进三级缓存，并将二级缓存中的移除。 
 */
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    //一级缓存：即单例池
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        //从三级缓存中拿 
        singletonObject = this.earlySingletonObjects.get(beanName);
        //如果拿不到
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        //从二级缓存中拿
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        //如果拿到了 
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            //放入三级缓存中
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            //将二级缓存中的移除
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
(String), 原创(String), 169(Integer), true(Boolean), true(Boolean), true(Boolean), true(Boolean), true(Boolean), 2021-04-03 01:26:55.386(Timestamp), 2021-04-04 23:40:56.51(Timestamp), 14(Long), 1(Long), 34(Long)
2021-04-25 19:12:13.769 DEBUG 19964 --- [http-nio-8080-exec-1] c.yi.blog.mapper.BlogMapper.updateById   : <==    Updates: 1
2021-04-25 19:12:13.802  INFO 19964 --- [http-nio-8080-exec-1] com.yi.blog.aspect.LogAspect             : Result:archivedetails
2021-04-25 19:12:23.487  INFO 19964 --- [http-nio-8080-exec-3] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/blog/34', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.blog', args=[34, {}]}
2021-04-25 19:12:23.498 DEBUG 19964 --- [http-nio-8080-exec-3] com.yi.blog.mapper.UserMapper.selectOne  : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE (id = ?) 
2021-04-25 19:12:23.498 DEBUG 19964 --- [http-nio-8080-exec-3] com.yi.blog.mapper.UserMapper.selectOne  : ==> Parameters: 1(Integer)
2021-04-25 19:12:23.509 DEBUG 19964 --- [http-nio-8080-exec-3] com.yi.blog.mapper.UserMapper.selectOne  : <==      Total: 1
2021-04-25 19:12:23.520 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.selectById   : ==>  Preparing: SELECT id,title,content,first_picture,stamp,views,appreciate,original,comments,published,recommend,create_time,update_time,blog_type_id,user_id FROM blog WHERE id=? 
2021-04-25 19:12:23.520 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.selectById   : ==> Parameters: 34(Long)
2021-04-25 19:12:23.544 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.selectById   : <==      Total: 1
2021-04-25 19:12:23.544 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:12:23.545 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:12:23.556 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:12:23.571 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.updateById   : ==>  Preparing: UPDATE blog SET title=?, content=?, stamp=?, views=?, appreciate=?, original=?, comments=?, published=?, recommend=?, create_time=?, update_time=?, blog_type_id=?, user_id=? WHERE id=? 
2021-04-25 19:12:23.573 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.updateById   : ==> Parameters: Spring(一)(String), # Spring:循环依赖
## 什么是循环依赖?

```java
@ComponentScan("com.yi")
public class MyConfig {

}
```
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
```java
@Component
public class TwoService {
    @Autowired
    OneService oneService;

    public TwoService() {
        System.out.println("Construct TwoService");
    }

    public void getOneService(){
        System.out.println(oneService);
    }
}
```
```java
public class Test {
    public static void main(String[] args) {
        //初始化Spring容器
        AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);

        ac.getBean(OneService.class).getTwoService();
    }
}
```
这四个代码片段，即展示了Spring当中的循环依赖。
明白循环依赖，首先要明白依赖注入。
# Spring：依赖注入
依赖注入是在Spring容器初始化的时候完成的。这期间有一个过程：以上述代码为例，初始化`AnnotationConfigApplicationContext`容器，首先读取`MyConfig`类，扫描包下的Spring管理的注解的类，然后利用这些类的信息，进行bean的初始化。
初始化bean：1、2、3、4、5、6、...N步,分好多步，接下来，看一下这些具体的步骤。
## Spring bean的初始化
普通类的初始化，简单的来说，就是.java结尾的类，在经过编译后，生成.class字节码文件，然后jvm读取这些文件，将读取的类信息，放置到方法区，等到new的时候，利用这些信息，在堆空间开辟空间，产生一个对象。
而Spring bean的初始化，要经过更繁琐的过程。
### scan:
将扫描到的由Spring管理的类，生成类信息。
### parse：
接下来，Spring底层会解析这些类的信息，将一个一个的类，生成一个一个的`BeanDefinition`接口的实现类。
这些`BeanDefinition`类中，保存的是扫描到的类的信息，信息大致有：beanSocpe，扫描到的类是不是单例的？isLazy，扫描到的类是不是标注了`@Lazy`注解，是不是懒加载？不同的信息，Spring将做不同的策略。
### put map：
接下来，把这些`BeanDefinition`对象，放置到一个map中，map的key即扫描类的类名，value即`BeanDefinition`对象。
### 实例化：
接下来，将遍历这个map，然后实例化。实例化出的对象，依然放到新的map当中(`@Lazy`、原型，等特殊对象，此刻不会实例化。
#### Spring bean的生命周期
```java
public void refresh() throws BeansException, IllegalStateException {
        synchronized(this.startupShutdownMonitor) {
            StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");
            this.prepareRefresh();
            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
            this.prepareBeanFactory(beanFactory);

            try {
                this.postProcessBeanFactory(beanFactory);
                StartupStep beanPostProcess = this.applicationStartup.start("spring.context.beans.post-process");
                this.invokeBeanFactoryPostProcessors(beanFactory);
                this.registerBeanPostProcessors(beanFactory);
                beanPostProcess.end();
                this.initMessageSource();
                this.initApplicationEventMulticaster();
                this.onRefresh();
                this.registerListeners();
                this.finishBeanFactoryInitialization(beanFactory);
                this.finishRefresh();
            } catch (BeansException var10) {
                if (this.logger.isWarnEnabled()) {
                    this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var10);
                }

                this.destroyBeans();
                this.cancelRefresh(var10);
                throw var10;
            } finally {
                this.resetCommonCaches();
                contextRefresh.end();
            }

        }
    }
```
`this.invokeBeanFactoryPostProcessors(beanFactory);`此行完成了Spring bean的扫描，此刻，`BeanDefinition`对象已经全部加载到了map当中。
`this.finishBeanFactoryInitialization(beanFactory);`此行完成了实例化。
bean的生命周期，即在`this.finishBeanFactoryInitialization(beanFactory);`中。
进入此方法：
```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
        if (beanFactory.containsBean("conversionService") && beanFactory.isTypeMatch("conversionService", ConversionService.class)) {
            beanFactory.setConversionService((ConversionService)beanFactory.getBean("conversionService", ConversionService.class));
        }

        if (!beanFactory.hasEmbeddedValueResolver()) {
            beanFactory.addEmbeddedValueResolver((strVal) -> {
                return this.getEnvironment().resolvePlaceholders(strVal);
            });
        }

        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
        String[] var3 = weaverAwareNames;
        int var4 = weaverAwareNames.length;

        for(int var5 = 0; var5 < var4; ++var5) {
            String weaverAwareName = var3[var5];
            this.getBean(weaverAwareName);
        }

        beanFactory.setTempClassLoader((ClassLoader)null);
        beanFactory.freezeConfiguration();
        beanFactory.preInstantiateSingletons();
    }
```
`beanFactory.preInstantiateSingletons();`此行实例化所有的单例，非Lazy的。
进入此方法：
```java
public void preInstantiateSingletons() throws BeansException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Pre-instantiating singletons in " + this);
        }

        List<String> beanNames = new ArrayList(this.beanDefinitionNames);
        Iterator var2 = beanNames.iterator();

        while(true) {
            String beanName;
            Object bean;
            do {
                while(true) {
                    RootBeanDefinition bd;
                    do {
                        do {
                            do {
                                if (!var2.hasNext()) {
                                    var2 = beanNames.iterator();

                                    while(var2.hasNext()) {
                                        beanName = (String)var2.next();
                                        Object singletonInstance = this.getSingleton(beanName);
                                        if (singletonInstance instanceof SmartInitializingSingleton) {
                                            StartupStep smartInitialize = this.getApplicationStartup().start("spring.beans.smart-initialize").tag("beanName", beanName);
                                            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;
                                            if (System.getSecurityManager() != null) {
                                                AccessController.doPrivileged(() -> {
                                                    smartSingleton.afterSingletonsInstantiated();
                                                    return null;
                                                }, this.getAccessControlContext());
                                            } else {
                                                smartSingleton.afterSingletonsInstantiated();
                                            }

                                            smartInitialize.end();
                                        }
                                    }

                                    return;
                                }

                                beanName = (String)var2.next();
                                bd = this.getMergedLocalBeanDefinition(beanName);
                            } while(bd.isAbstract());
                        } while(!bd.isSingleton());
                    } while(bd.isLazyInit());

                    if (this.isFactoryBean(beanName)) {
                        bean = this.getBean("&" + beanName);
                        break;
                    }

                    this.getBean(beanName);
                }
            } while(!(bean instanceof FactoryBean));

            FactoryBean<?> factory = (FactoryBean)bean;
            boolean isEagerInit;
            if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                SmartFactoryBean var10000 = (SmartFactoryBean)factory;
                ((SmartFactoryBean)factory).getClass();
                isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, this.getAccessControlContext());
            } else {
                isEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean)factory).isEagerInit();
            }

            if (isEagerInit) {
                this.getBean(beanName);
            }
        }
    }
```
此方法，在遍历`BeanDefinition`对象，来验证这些`BeanDefinition`对象是不是可以将这些描述的bean实例化，因为有些非单例的bean，接下来不应该实例化的，所以有这么一个校验的过程。
接下来：进入此方法：`this.getBean(beanName);`
最核心的方法：
```java
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
        String beanName = this.transformedBeanName(name);
        Object sharedInstance = this.getSingleton(beanName);
        Object beanInstance;
        if (sharedInstance != null && args == null) {
            if (this.logger.isTraceEnabled()) {
                if (this.isSingletonCurrentlyInCreation(beanName)) {
                    this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
                } else {
                    this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
                }
            }

            beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
        } else {
            if (this.isPrototypeCurrentlyInCreation(beanName)) {
                throw new BeanCurrentlyInCreationException(beanName);
            }

            BeanFactory parentBeanFactory = this.getParentBeanFactory();
            if (parentBeanFactory != null && !this.containsBeanDefinition(beanName)) {
                String nameToLookup = this.originalBeanName(name);
                if (parentBeanFactory instanceof AbstractBeanFactory) {
                    return ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
                }

                if (args != null) {
                    return parentBeanFactory.getBean(nameToLookup, args);
                }

                if (requiredType != null) {
                    return parentBeanFactory.getBean(nameToLookup, requiredType);
                }

                return parentBeanFactory.getBean(nameToLookup);
            }

            if (!typeCheckOnly) {
                this.markBeanAsCreated(beanName);
            }

            StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate").tag("beanName", name);

            try {
                if (requiredType != null) {
                    beanCreation.tag("beanType", requiredType::toString);
                }

                RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);
                this.checkMergedBeanDefinition(mbd, beanName, args);
                String[] dependsOn = mbd.getDependsOn();
                String[] var12;
                if (dependsOn != null) {
                    var12 = dependsOn;
                    int var13 = dependsOn.length;

                    for(int var14 = 0; var14 < var13; ++var14) {
                        String dep = var12[var14];
                        if (this.isDependent(beanName, dep)) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                        }

                        this.registerDependentBean(dep, beanName);

                        try {
                            this.getBean(dep);
                        } catch (NoSuchBeanDefinitionException var31) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "'" + beanName + "' depends on missing bean '" + dep + "'", var31);
                        }
                    }
                }

                if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                } else if (mbd.isPrototype()) {
                    var12 = null;

                    Object prototypeInstance;
                    try {
                        this.beforePrototypeCreation(beanName);
                        prototypeInstance = this.createBean(beanName, mbd, args);
                    } finally {
                        this.afterPrototypeCreation(beanName);
                    }

                    beanInstance = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                } else {
                    String scopeName = mbd.getScope();
                    if (!StringUtils.hasLength(scopeName)) {
                        throw new IllegalStateException("No scope name defined for bean ��" + beanName + "'");
                    }

                    Scope scope = (Scope)this.scopes.get(scopeName);
                    if (scope == null) {
                        throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                    }

                    try {
                        Object scopedInstance = scope.get(beanName, () -> {
                            this.beforePrototypeCreation(beanName);

                            Object var4;
                            try {
                                var4 = this.createBean(beanName, mbd, args);
                            } finally {
                                this.afterPrototypeCreation(beanName);
                            }

                            return var4;
                        });
                        beanInstance = this.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                    } catch (IllegalStateException var30) {
                        throw new ScopeNotActiveException(beanName, scopeName, var30);
                    }
                }
            } catch (BeansException var32) {
                beanCreation.tag("exception", var32.getClass().toString());
                beanCreation.tag("message", String.valueOf(var32.getMessage()));
                this.cleanupAfterBeanCreationFailure(beanName);
                throw var32;
            } finally {
                beanCreation.end();
            }
        }

        return this.adaptBeanInstance(name, beanInstance, requiredType);
    }
```
`String beanName = this.transformedBeanName(name);`此行，先认为它是校验bean的名字是不是合法，其实还有很多其他作用；
`Object sharedInstance = this.getSingleton(beanName);`此行，是从一个map中尝试拿一下，这个bean，这个map是一个ConcurrentHashMap，是常说的Spring容器，但准确的应该叫Spring单例池，但此刻肯定是拿不到的，它为什么要拿一下呢?这里有个很关键的方法：`isSingletonCurrentlyInCreation(beanName)`
```java
String beanName = this.transformedBeanName(name);
Object sharedInstance = this.getSingleton(beanName);
Object beanInstance;
if (sharedInstance != null && args == null) {
    if (this.logger.isTraceEnabled()) {
        if (this.isSingletonCurrentlyInCreation(beanName)) {
            this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
        } else {
            this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
        }
    }

    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
}
```
至此，先跳过这部分。
再回到doGetBean方法：来到：
```java
if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }
```
此处，就要进行创建对象了：
```java
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Creating instance of bean '" + beanName + "'");
        }

        RootBeanDefinition mbdToUse = mbd;
        Class<?> resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
        if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
            mbdToUse = new RootBeanDefinition(mbd);
            mbdToUse.setBeanClass(resolvedClass);
        }

        try {
            mbdToUse.prepareMethodOverrides();
        } catch (BeanDefinitionValidationException var9) {
            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", var9);
        }

        Object beanInstance;
        try {
            beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);
            if (beanInstance != null) {
                return beanInstance;
            }
        } catch (Throwable var10) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", var10);
        }

        try {
            beanInstance = this.doCreateBean(beanName, mbdToUse, args);
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Finished creating instance of bean '" + beanName + "'");
            }

            return beanInstance;
        } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) {
            throw var7;
        } catch (Throwable var8) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", var8);
        }
    }
```
上面这段代码，可以看到，就是通过`BeanDefinition`对象拿到bean的Class类的对象出来，准备创建对象，就是拿到该类的构造器等信息，来实例化。虽然是实例化了，但并不是完整的Spring bean。如下代码片段
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    @PostConstruct
    public void aa(){
        //Spring bean生命周期初始化回调方法
        System.out.println("init");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
它这一步，仅仅是创建了OneService的基本对象，@Autowired，还有AOP功能，@PostConstruct等等都没有做，仅仅是new出来了这个基本对象。
在创建的过程中，进入doCreateBean方法中：
```java
//判断是否允许循环依赖
//主要就是this.allowCircularReferences,而Spring关闭默认允许循环依赖的关键也就是这里
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }

    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}
```
## 问题：怎么关闭Spring默认的允许循环依赖
1、直接修改源码，赋值allowCircularReferences属性为false。
2、手动refresh：
```java
//1、初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext(MyConfig.class);
//2、拿到beanFactory
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
//但这样其实没有用,因为1、步已经完成了容器的初始化。
```
正确的做法：
```java
//初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext();
//先调用默认构造器，然后自己来实现其构造器中的两个关键方法：register和refresh
ac.register(MyConfig.class);
//在此关闭循环依赖
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
ac.refresh();
```
回到创建过程：
```java
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }
    //在此进行第四次后置处理器，判断是否需要AOP
    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}

Object exposedObject = bean;

try {
    //填充属性，也就是常常说的自动注入
    //里面会完成第五次和第六次后置处理器的调用
    this.populateBean(beanName, mbd, instanceWrapper);
    //初始化bean
    //里面会完成第七次和第八次后置处理器的调用
    exposedObject = this.initializeBean(beanName, exposedObject, mbd);
} catch (Throwable var18) {
    if (var18 instanceof BeanCreationException && beanName.equals(((BeanCreationException)var18).getBeanName())) {
        throw (BeanCreationException)var18;
    }

    throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", var18);
}
```
进入populateBean方法：
```java
if (hasInstAwareBpps) {
    if (pvs == null) {
        pvs = mbd.getPropertyValues();
    }

    PropertyValues pvsToUse;
    for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {
        InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();
        pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
        if (pvsToUse == null) {
            if (filteredPds == null) {
                filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            }

            pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
                return;
            }
        }
    }
}
```
此行：`pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);`完成后，完成注入，比如TwoService，这时候就注入了进来。
注意，此处是个for循环，该循环在遍历后置处理器BeanPostProcessors，然后不同的BeanPostProcessor作不同的事情，比如常说的@Autowired注解，和@Resource注解的区别，这两个注解的组件走到这里的时候，会有不同的后置处理器来处理。
至此，来看开始循环注入的问题：
首先:初始化容器
```java
AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);
```
调用refresh方法：
```java
this.refresh();
```
经过：
```java
this.invokeBeanFactoryPostProcessors(beanFactory);
```
后完成扫描。
经过：
```java
this.finishBeanFactoryInitialization(beanFactory);
```
后完成bean的初始化。在：`this.finishBeanFactoryInitialization(beanFactory);`中，又进行了实例化所有的单例，非Lazy的bean：
```java
beanFactory.preInstantiateSingletons();
```
这里面，创建对象的过程是，先new出了基本的对象，然后接着进行属性填充：
```java
this.populateBean(beanName, mbd, instanceWrapper);
```
就是在此时，填充TwoService，这时候他会从容器中去拿TwoService这个bean，就是单例池中去拿，这时候肯定拿不到。
这时候就到了上面提到的：去池子中拿，拿不到，这时候有一个很关键的判断：
`if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName))`
```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
这个判断条件是不成立的。如果该条件成立，那么就要去三级缓存中拿。
# 循环依赖类的创建流程总结：
OK，循环依赖的两个类加载的过程：
调用构造方法new出OneService对象-->如果是单例，还会把自己放到一个代表正在创建中的Set集合中，如果开启了循环依赖，就会把当前的OneService的对象放到二级缓存中-->继续走，走到populateBean要进行填充TwoService-->从容器中找，这时候找不到。此刻就有上边这个判断，是不是正在创建的bean，如果此判断成功进入，就会从三级缓存中拿出来。-->拿不到，条件也没成立，这时候，就要new出TwoService来，当然此时new出的来TwoServcie对象，也要走bean的生命周期，那么它最终还是会走到populateBean这个方法，它也会去填充属性--->从容器中找OneService的bean，拿不到，所以它又要实例化一遍OneService，但这个过程中，但是此时有个判断条件却成立了，因为OneService确实是正在创建中，它从二级缓存中拿，是能拿到的，之前的过程存进去了。这时候，拿到OneService的对象，不等于null，就给TwoService注入了。
```java
/**
 * 比如第一次加载OneService,就会把自己放入二级缓存，当OneService进行到populateBean时，就会准备注入TwoService，
 * TwoService，也一样，最后进行到populateBean，从单例池中拿OneService，拿不到，继续从三级中拿，拿不到，继续从
 * 二级中拿，拿到了，就把OneService放进三级缓存，并将二级缓存中的移除。 
 */
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    //一级缓存：即单例池
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        //从三级缓存中拿 
        singletonObject = this.earlySingletonObjects.get(beanName);
        //如果拿不到
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        //从二级缓存中拿
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        //如果拿到了 
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            //放入三级缓存中
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            //将二级缓存中的移除
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
(String), 原创(String), 170(Integer), true(Boolean), true(Boolean), true(Boolean), true(Boolean), true(Boolean), 2021-04-03 01:26:55.386(Timestamp), 2021-04-04 23:40:56.51(Timestamp), 14(Long), 1(Long), 34(Long)
2021-04-25 19:12:23.597 DEBUG 19964 --- [http-nio-8080-exec-3] c.yi.blog.mapper.BlogMapper.updateById   : <==    Updates: 1
2021-04-25 19:12:23.633  INFO 19964 --- [http-nio-8080-exec-3] com.yi.blog.aspect.LogAspect             : Result:archivedetails
2021-04-25 19:12:43.280  INFO 19964 --- [http-nio-8080-exec-7] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/blog/34', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.blog', args=[34, {}]}
2021-04-25 19:12:43.291 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.UserMapper.selectOne  : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE (id = ?) 
2021-04-25 19:12:43.292 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.UserMapper.selectOne  : ==> Parameters: 1(Integer)
2021-04-25 19:12:43.302 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.UserMapper.selectOne  : <==      Total: 1
2021-04-25 19:12:43.313 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.BlogMapper.selectById   : ==>  Preparing: SELECT id,title,content,first_picture,stamp,views,appreciate,original,comments,published,recommend,create_time,update_time,blog_type_id,user_id FROM blog WHERE id=? 
2021-04-25 19:12:43.313 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.BlogMapper.selectById   : ==> Parameters: 34(Long)
2021-04-25 19:12:43.337 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.BlogMapper.selectById   : <==      Total: 1
2021-04-25 19:12:43.337 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:12:43.338 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:12:43.348 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:12:43.349 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.BlogMapper.updateById   : ==>  Preparing: UPDATE blog SET title=?, content=?, stamp=?, views=?, appreciate=?, original=?, comments=?, published=?, recommend=?, create_time=?, update_time=?, blog_type_id=?, user_id=? WHERE id=? 
2021-04-25 19:12:43.349 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.BlogMapper.updateById   : ==> Parameters: Spring(一)(String), # Spring:循环依赖
## 什么是循环依赖?

```java
@ComponentScan("com.yi")
public class MyConfig {

}
```
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
```java
@Component
public class TwoService {
    @Autowired
    OneService oneService;

    public TwoService() {
        System.out.println("Construct TwoService");
    }

    public void getOneService(){
        System.out.println(oneService);
    }
}
```
```java
public class Test {
    public static void main(String[] args) {
        //初始化Spring容器
        AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);

        ac.getBean(OneService.class).getTwoService();
    }
}
```
这四个代码片段，即展示了Spring当中的循环依赖。
明白循环依赖，首先要明白依赖注入。
# Spring：依赖注入
依赖注入是在Spring容器初始化的时候完成的。这期间有一个过程：以上述代码为例，初始化`AnnotationConfigApplicationContext`容器，首先读取`MyConfig`类，扫描包下的Spring管理的注解的类，然后利用这些类的信息，进行bean的初始化。
初始化bean：1、2、3、4、5、6、...N步,分好多步，接下来，看一下这些具体的步骤。
## Spring bean的初始化
普通类的初始化，简单的来说，就是.java结尾的类，在经过编译后，生成.class字节码文件，然后jvm读取这些文件，将读取的类信息，放置到方法区，等到new的时候，利用这些信息，在堆空间开辟空间，产生一个对象。
而Spring bean的初始化，要经过更繁琐的过程。
### scan:
将扫描到的由Spring管理的类，生成类信息。
### parse：
接下来，Spring底层会解析这些类的信息，将一个一个的类，生成一个一个的`BeanDefinition`接口的实现类。
这些`BeanDefinition`类中，保存的是扫描到的类的信息，信息大致有：beanSocpe，扫描到的类是不是单例的？isLazy，扫描到的类是不是标注了`@Lazy`注解，是不是懒加载？不同的信息，Spring将做不同的策略。
### put map：
接下来，把这些`BeanDefinition`对象，放置到一个map中，map的key即扫描类的类名，value即`BeanDefinition`对象。
### 实例化：
接下来，将遍历这个map，然后实例化。实例化出的对象，依然放到新的map当中(`@Lazy`、原型，等特殊对象，此刻不会实例化。
#### Spring bean的生命周期
```java
public void refresh() throws BeansException, IllegalStateException {
        synchronized(this.startupShutdownMonitor) {
            StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");
            this.prepareRefresh();
            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
            this.prepareBeanFactory(beanFactory);

            try {
                this.postProcessBeanFactory(beanFactory);
                StartupStep beanPostProcess = this.applicationStartup.start("spring.context.beans.post-process");
                this.invokeBeanFactoryPostProcessors(beanFactory);
                this.registerBeanPostProcessors(beanFactory);
                beanPostProcess.end();
                this.initMessageSource();
                this.initApplicationEventMulticaster();
                this.onRefresh();
                this.registerListeners();
                this.finishBeanFactoryInitialization(beanFactory);
                this.finishRefresh();
            } catch (BeansException var10) {
                if (this.logger.isWarnEnabled()) {
                    this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var10);
                }

                this.destroyBeans();
                this.cancelRefresh(var10);
                throw var10;
            } finally {
                this.resetCommonCaches();
                contextRefresh.end();
            }

        }
    }
```
`this.invokeBeanFactoryPostProcessors(beanFactory);`此行完成了Spring bean的扫描，此刻，`BeanDefinition`对象已经全部加载到了map当中。
`this.finishBeanFactoryInitialization(beanFactory);`此行完成了实例化。
bean的生命周期，即在`this.finishBeanFactoryInitialization(beanFactory);`中。
进入此方法：
```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
        if (beanFactory.containsBean("conversionService") && beanFactory.isTypeMatch("conversionService", ConversionService.class)) {
            beanFactory.setConversionService((ConversionService)beanFactory.getBean("conversionService", ConversionService.class));
        }

        if (!beanFactory.hasEmbeddedValueResolver()) {
            beanFactory.addEmbeddedValueResolver((strVal) -> {
                return this.getEnvironment().resolvePlaceholders(strVal);
            });
        }

        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
        String[] var3 = weaverAwareNames;
        int var4 = weaverAwareNames.length;

        for(int var5 = 0; var5 < var4; ++var5) {
            String weaverAwareName = var3[var5];
            this.getBean(weaverAwareName);
        }

        beanFactory.setTempClassLoader((ClassLoader)null);
        beanFactory.freezeConfiguration();
        beanFactory.preInstantiateSingletons();
    }
```
`beanFactory.preInstantiateSingletons();`此行实例化所有的单例，非Lazy的。
进入此方法：
```java
public void preInstantiateSingletons() throws BeansException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Pre-instantiating singletons in " + this);
        }

        List<String> beanNames = new ArrayList(this.beanDefinitionNames);
        Iterator var2 = beanNames.iterator();

        while(true) {
            String beanName;
            Object bean;
            do {
                while(true) {
                    RootBeanDefinition bd;
                    do {
                        do {
                            do {
                                if (!var2.hasNext()) {
                                    var2 = beanNames.iterator();

                                    while(var2.hasNext()) {
                                        beanName = (String)var2.next();
                                        Object singletonInstance = this.getSingleton(beanName);
                                        if (singletonInstance instanceof SmartInitializingSingleton) {
                                            StartupStep smartInitialize = this.getApplicationStartup().start("spring.beans.smart-initialize").tag("beanName", beanName);
                                            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;
                                            if (System.getSecurityManager() != null) {
                                                AccessController.doPrivileged(() -> {
                                                    smartSingleton.afterSingletonsInstantiated();
                                                    return null;
                                                }, this.getAccessControlContext());
                                            } else {
                                                smartSingleton.afterSingletonsInstantiated();
                                            }

                                            smartInitialize.end();
                                        }
                                    }

                                    return;
                                }

                                beanName = (String)var2.next();
                                bd = this.getMergedLocalBeanDefinition(beanName);
                            } while(bd.isAbstract());
                        } while(!bd.isSingleton());
                    } while(bd.isLazyInit());

                    if (this.isFactoryBean(beanName)) {
                        bean = this.getBean("&" + beanName);
                        break;
                    }

                    this.getBean(beanName);
                }
            } while(!(bean instanceof FactoryBean));

            FactoryBean<?> factory = (FactoryBean)bean;
            boolean isEagerInit;
            if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                SmartFactoryBean var10000 = (SmartFactoryBean)factory;
                ((SmartFactoryBean)factory).getClass();
                isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, this.getAccessControlContext());
            } else {
                isEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean)factory).isEagerInit();
            }

            if (isEagerInit) {
                this.getBean(beanName);
            }
        }
    }
```
此方法，在遍历`BeanDefinition`对象，来验证这些`BeanDefinition`对象是不是可以将这些描述的bean实例化，因为有些非单例的bean，接下来不应该实例化的，所以有这么一个校验的过程。
接下来：进入此方法：`this.getBean(beanName);`
最核心的方法：
```java
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
        String beanName = this.transformedBeanName(name);
        Object sharedInstance = this.getSingleton(beanName);
        Object beanInstance;
        if (sharedInstance != null && args == null) {
            if (this.logger.isTraceEnabled()) {
                if (this.isSingletonCurrentlyInCreation(beanName)) {
                    this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
                } else {
                    this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
                }
            }

            beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
        } else {
            if (this.isPrototypeCurrentlyInCreation(beanName)) {
                throw new BeanCurrentlyInCreationException(beanName);
            }

            BeanFactory parentBeanFactory = this.getParentBeanFactory();
            if (parentBeanFactory != null && !this.containsBeanDefinition(beanName)) {
                String nameToLookup = this.originalBeanName(name);
                if (parentBeanFactory instanceof AbstractBeanFactory) {
                    return ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
                }

                if (args != null) {
                    return parentBeanFactory.getBean(nameToLookup, args);
                }

                if (requiredType != null) {
                    return parentBeanFactory.getBean(nameToLookup, requiredType);
                }

                return parentBeanFactory.getBean(nameToLookup);
            }

            if (!typeCheckOnly) {
                this.markBeanAsCreated(beanName);
            }

            StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate").tag("beanName", name);

            try {
                if (requiredType != null) {
                    beanCreation.tag("beanType", requiredType::toString);
                }

                RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);
                this.checkMergedBeanDefinition(mbd, beanName, args);
                String[] dependsOn = mbd.getDependsOn();
                String[] var12;
                if (dependsOn != null) {
                    var12 = dependsOn;
                    int var13 = dependsOn.length;

                    for(int var14 = 0; var14 < var13; ++var14) {
                        String dep = var12[var14];
                        if (this.isDependent(beanName, dep)) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                        }

                        this.registerDependentBean(dep, beanName);

                        try {
                            this.getBean(dep);
                        } catch (NoSuchBeanDefinitionException var31) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "'" + beanName + "' depends on missing bean '" + dep + "'", var31);
                        }
                    }
                }

                if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                } else if (mbd.isPrototype()) {
                    var12 = null;

                    Object prototypeInstance;
                    try {
                        this.beforePrototypeCreation(beanName);
                        prototypeInstance = this.createBean(beanName, mbd, args);
                    } finally {
                        this.afterPrototypeCreation(beanName);
                    }

                    beanInstance = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                } else {
                    String scopeName = mbd.getScope();
                    if (!StringUtils.hasLength(scopeName)) {
                        throw new IllegalStateException("No scope name defined for bean ��" + beanName + "'");
                    }

                    Scope scope = (Scope)this.scopes.get(scopeName);
                    if (scope == null) {
                        throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                    }

                    try {
                        Object scopedInstance = scope.get(beanName, () -> {
                            this.beforePrototypeCreation(beanName);

                            Object var4;
                            try {
                                var4 = this.createBean(beanName, mbd, args);
                            } finally {
                                this.afterPrototypeCreation(beanName);
                            }

                            return var4;
                        });
                        beanInstance = this.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                    } catch (IllegalStateException var30) {
                        throw new ScopeNotActiveException(beanName, scopeName, var30);
                    }
                }
            } catch (BeansException var32) {
                beanCreation.tag("exception", var32.getClass().toString());
                beanCreation.tag("message", String.valueOf(var32.getMessage()));
                this.cleanupAfterBeanCreationFailure(beanName);
                throw var32;
            } finally {
                beanCreation.end();
            }
        }

        return this.adaptBeanInstance(name, beanInstance, requiredType);
    }
```
`String beanName = this.transformedBeanName(name);`此行，先认为它是校验bean的名字是不是合法，其实还有很多其他作用；
`Object sharedInstance = this.getSingleton(beanName);`此行，是从一个map中尝试拿一下，这个bean，这个map是一个ConcurrentHashMap，是常说的Spring容器，但准确的应该叫Spring单例池，但此刻肯定是拿不到的，它为什么要拿一下呢?这里有个很关键的方法：`isSingletonCurrentlyInCreation(beanName)`
```java
String beanName = this.transformedBeanName(name);
Object sharedInstance = this.getSingleton(beanName);
Object beanInstance;
if (sharedInstance != null && args == null) {
    if (this.logger.isTraceEnabled()) {
        if (this.isSingletonCurrentlyInCreation(beanName)) {
            this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
        } else {
            this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
        }
    }

    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
}
```
至此，先跳过这部分。
再回到doGetBean方法：来到：
```java
if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }
```
此处，就要进行创建对象了：
```java
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Creating instance of bean '" + beanName + "'");
        }

        RootBeanDefinition mbdToUse = mbd;
        Class<?> resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
        if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
            mbdToUse = new RootBeanDefinition(mbd);
            mbdToUse.setBeanClass(resolvedClass);
        }

        try {
            mbdToUse.prepareMethodOverrides();
        } catch (BeanDefinitionValidationException var9) {
            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", var9);
        }

        Object beanInstance;
        try {
            beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);
            if (beanInstance != null) {
                return beanInstance;
            }
        } catch (Throwable var10) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", var10);
        }

        try {
            beanInstance = this.doCreateBean(beanName, mbdToUse, args);
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Finished creating instance of bean '" + beanName + "'");
            }

            return beanInstance;
        } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) {
            throw var7;
        } catch (Throwable var8) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", var8);
        }
    }
```
上面这段代码，可以看到，就是通过`BeanDefinition`对象拿到bean的Class类的对象出来，准备创建对象，就是拿到该类的构造器等信息，来实例化。虽然是实例化了，但并不是完整的Spring bean。如下代码片段
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    @PostConstruct
    public void aa(){
        //Spring bean生命周期初始化回调方法
        System.out.println("init");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
它这一步，仅仅是创建了OneService的基本对象，@Autowired，还有AOP功能，@PostConstruct等等都没有做，仅仅是new出来了这个基本对象。
在创建的过程中，进入doCreateBean方法中：
```java
//判断是否允许循环依赖
//主要就是this.allowCircularReferences,而Spring关闭默认允许循环依赖的关键也就是这里
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }

    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}
```
## 问题：怎么关闭Spring默认的允许循环依赖
1、直接修改源码，赋值allowCircularReferences属性为false。
2、手动refresh：
```java
//1、初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext(MyConfig.class);
//2、拿到beanFactory
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
//但这样其实没有用,因为1、步已经完成了容器的初始化。
```
正确的做法：
```java
//初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext();
//先调用默认构造器，然后自己来实现其构造器中的两个关键方法：register和refresh
ac.register(MyConfig.class);
//在此关闭循环依赖
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
ac.refresh();
```
回到创建过程：
```java
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }
    //在此进行第四次后置处理器，判断是否需要AOP
    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}

Object exposedObject = bean;

try {
    //填充属性，也就是常常说的自动注入
    //里面会完成第五次和第六次后置处理器的调用
    this.populateBean(beanName, mbd, instanceWrapper);
    //初始化bean
    //里面会完成第七次和第八次后置处理器的调用
    exposedObject = this.initializeBean(beanName, exposedObject, mbd);
} catch (Throwable var18) {
    if (var18 instanceof BeanCreationException && beanName.equals(((BeanCreationException)var18).getBeanName())) {
        throw (BeanCreationException)var18;
    }

    throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", var18);
}
```
进入populateBean方法：
```java
if (hasInstAwareBpps) {
    if (pvs == null) {
        pvs = mbd.getPropertyValues();
    }

    PropertyValues pvsToUse;
    for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {
        InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();
        pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
        if (pvsToUse == null) {
            if (filteredPds == null) {
                filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            }

            pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
                return;
            }
        }
    }
}
```
此行：`pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);`完成后，完成注入，比如TwoService，这时候就注入了进来。
注意，此处是个for循环，该循环在遍历后置处理器BeanPostProcessors，然后不同的BeanPostProcessor作不同的事情，比如常说的@Autowired注解，和@Resource注解的区别，这两个注解的组件走到这里的时候，会有不同的后置处理器来处理。
至此，来看开始循环注入的问题：
首先:初始化容器
```java
AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);
```
调用refresh方法：
```java
this.refresh();
```
经过：
```java
this.invokeBeanFactoryPostProcessors(beanFactory);
```
后完成扫描。
经过：
```java
this.finishBeanFactoryInitialization(beanFactory);
```
后完成bean的初始化。在：`this.finishBeanFactoryInitialization(beanFactory);`中，又进行了实例化所有的单例，非Lazy的bean：
```java
beanFactory.preInstantiateSingletons();
```
这里面，创建对象的过程是，先new出了基本的对象，然后接着进行属性填充：
```java
this.populateBean(beanName, mbd, instanceWrapper);
```
就是在此时，填充TwoService，这时候他会从容器中去拿TwoService这个bean，就是单例池中去拿，这时候肯定拿不到。
这时候就到了上面提到的：去池子中拿，拿不到，这时候有一个很关键的判断：
`if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName))`
```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
这个判断条件是不成立的。如果该条件成立，那么就要去三级缓存中拿。
# 循环依赖类的创建流程总结：
OK，循环依赖的两个类加载的过程：
调用构造方法new出OneService对象-->如果是单例，还会把自己放到一个代表正在创建中的Set集合中，如果开启了循环依赖，就会把当前的OneService的对象放到二级缓存中-->继续走，走到populateBean要进行填充TwoService-->从容器中找，这时候找不到。此刻就有上边这个判断，是不是正在创建的bean，如果此判断成功进入，就会从三级缓存中拿出来。-->拿不到，条件也没成立，这时候，就要new出TwoService来，当然此时new出的来TwoServcie对象，也要走bean的生命周期，那么它最终还是会走到populateBean这个方法，它也会去填充属性--->从容器中找OneService的bean，拿不到，所以它又要实例化一遍OneService，但这个过程中，但是此时有个判断条件却成立了，因为OneService确实是正在创建中，它从二级缓存中拿，是能拿到的，之前的过程存进去了。这时候，拿到OneService的对象，不等于null，就给TwoService注入了。
```java
/**
 * 比如第一次加载OneService,就会把自己放入二级缓存，当OneService进行到populateBean时，就会准备注入TwoService，
 * TwoService，也一样，最后进行到populateBean，从单例池中拿OneService，拿不到，继续从三级中拿，拿不到，继续从
 * 二级中拿，拿到了，就把OneService放进三级缓存，并将二级缓存中的移除。 
 */
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    //一级缓存：即单例池
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        //从三级缓存中拿 
        singletonObject = this.earlySingletonObjects.get(beanName);
        //如果拿不到
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        //从二级缓存中拿
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        //如果拿到了 
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            //放入三级缓存中
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            //将二级缓存中的移除
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
(String), 原创(String), 171(Integer), true(Boolean), true(Boolean), true(Boolean), true(Boolean), true(Boolean), 2021-04-03 01:26:55.386(Timestamp), 2021-04-04 23:40:56.51(Timestamp), 14(Long), 1(Long), 34(Long)
2021-04-25 19:12:43.374 DEBUG 19964 --- [http-nio-8080-exec-7] c.yi.blog.mapper.BlogMapper.updateById   : <==    Updates: 1
2021-04-25 19:12:43.408  INFO 19964 --- [http-nio-8080-exec-7] com.yi.blog.aspect.LogAspect             : Result:archivedetails
2021-04-25 19:13:01.764  INFO 19964 --- [http-nio-8080-exec-8] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/blog/34', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.IndexController.blog', args=[34, {}]}
2021-04-25 19:13:01.775 DEBUG 19964 --- [http-nio-8080-exec-8] com.yi.blog.mapper.UserMapper.selectOne  : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE (id = ?) 
2021-04-25 19:13:01.776 DEBUG 19964 --- [http-nio-8080-exec-8] com.yi.blog.mapper.UserMapper.selectOne  : ==> Parameters: 1(Integer)
2021-04-25 19:13:01.786 DEBUG 19964 --- [http-nio-8080-exec-8] com.yi.blog.mapper.UserMapper.selectOne  : <==      Total: 1
2021-04-25 19:13:01.796 DEBUG 19964 --- [http-nio-8080-exec-8] c.yi.blog.mapper.BlogMapper.selectById   : ==>  Preparing: SELECT id,title,content,first_picture,stamp,views,appreciate,original,comments,published,recommend,create_time,update_time,blog_type_id,user_id FROM blog WHERE id=? 
2021-04-25 19:13:01.796 DEBUG 19964 --- [http-nio-8080-exec-8] c.yi.blog.mapper.BlogMapper.selectById   : ==> Parameters: 34(Long)
2021-04-25 19:13:01.821 DEBUG 19964 --- [http-nio-8080-exec-8] c.yi.blog.mapper.BlogMapper.selectById   : <==      Total: 1
2021-04-25 19:13:01.822 DEBUG 19964 --- [http-nio-8080-exec-8] c.yi.blog.mapper.UserMapper.selectById   : ==>  Preparing: SELECT id,nickname,username,password,qq,wechat,email,province,city,avatar,views,type,create_time,update_time,user_signature FROM user WHERE id=? 
2021-04-25 19:13:01.823 DEBUG 19964 --- [http-nio-8080-exec-8] c.yi.blog.mapper.UserMapper.selectById   : ==> Parameters: 1(Long)
2021-04-25 19:13:01.834 DEBUG 19964 --- [http-nio-8080-exec-8] c.yi.blog.mapper.UserMapper.selectById   : <==      Total: 1
2021-04-25 19:13:01.835 DEBUG 19964 --- [http-nio-8080-exec-8] c.yi.blog.mapper.BlogMapper.updateById   : ==>  Preparing: UPDATE blog SET title=?, content=?, stamp=?, views=?, appreciate=?, original=?, comments=?, published=?, recommend=?, create_time=?, update_time=?, blog_type_id=?, user_id=? WHERE id=? 
2021-04-25 19:13:01.835 DEBUG 19964 --- [http-nio-8080-exec-8] c.yi.blog.mapper.BlogMapper.updateById   : ==> Parameters: Spring(一)(String), # Spring:循环依赖
## 什么是循环依赖?

```java
@ComponentScan("com.yi")
public class MyConfig {

}
```
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
```java
@Component
public class TwoService {
    @Autowired
    OneService oneService;

    public TwoService() {
        System.out.println("Construct TwoService");
    }

    public void getOneService(){
        System.out.println(oneService);
    }
}
```
```java
public class Test {
    public static void main(String[] args) {
        //初始化Spring容器
        AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);

        ac.getBean(OneService.class).getTwoService();
    }
}
```
这四个代码片段，即展示了Spring当中的循环依赖。
明白循环依赖，首先要明白依赖注入。
# Spring：依赖注入
依赖注入是在Spring容器初始化的时候完成的。这期间有一个过程：以上述代码为例，初始化`AnnotationConfigApplicationContext`容器，首先读取`MyConfig`类，扫描包下的Spring管理的注解的类，然后利用这些类的信息，进行bean的初始化。
初始化bean：1、2、3、4、5、6、...N步,分好多步，接下来，看一下这些具体的步骤。
## Spring bean的初始化
普通类的初始化，简单的来说，就是.java结尾的类，在经过编译后，生成.class字节码文件，然后jvm读取这些文件，将读取的类信息，放置到方法区，等到new的时候，利用这些信息，在堆空间开辟空间，产生一个对象。
而Spring bean的初始化，要经过更繁琐的过程。
### scan:
将扫描到的由Spring管理的类，生成类信息。
### parse：
接下来，Spring底层会解析这些类的信息，将一个一个的类，生成一个一个的`BeanDefinition`接口的实现类。
这些`BeanDefinition`类中，保存的是扫描到的类的信息，信息大致有：beanSocpe，扫描到的类是不是单例的？isLazy，扫描到的类是不是标注了`@Lazy`注解，是不是懒加载？不同的信息，Spring将做不同的策略。
### put map：
接下来，把这些`BeanDefinition`对象，放置到一个map中，map的key即扫描类的类名，value即`BeanDefinition`对象。
### 实例化：
接下来，将遍历这个map，然后实例化。实例化出的对象，依然放到新的map当中(`@Lazy`、原型，等特殊对象，此刻不会实例化。
#### Spring bean的生命周期
```java
public void refresh() throws BeansException, IllegalStateException {
        synchronized(this.startupShutdownMonitor) {
            StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");
            this.prepareRefresh();
            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
            this.prepareBeanFactory(beanFactory);

            try {
                this.postProcessBeanFactory(beanFactory);
                StartupStep beanPostProcess = this.applicationStartup.start("spring.context.beans.post-process");
                this.invokeBeanFactoryPostProcessors(beanFactory);
                this.registerBeanPostProcessors(beanFactory);
                beanPostProcess.end();
                this.initMessageSource();
                this.initApplicationEventMulticaster();
                this.onRefresh();
                this.registerListeners();
                this.finishBeanFactoryInitialization(beanFactory);
                this.finishRefresh();
            } catch (BeansException var10) {
                if (this.logger.isWarnEnabled()) {
                    this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var10);
                }

                this.destroyBeans();
                this.cancelRefresh(var10);
                throw var10;
            } finally {
                this.resetCommonCaches();
                contextRefresh.end();
            }

        }
    }
```
`this.invokeBeanFactoryPostProcessors(beanFactory);`此行完成了Spring bean的扫描，此刻，`BeanDefinition`对象已经全部加载到了map当中。
`this.finishBeanFactoryInitialization(beanFactory);`此行完成了实例化。
bean的生命周期，即在`this.finishBeanFactoryInitialization(beanFactory);`中。
进入此方法：
```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
        if (beanFactory.containsBean("conversionService") && beanFactory.isTypeMatch("conversionService", ConversionService.class)) {
            beanFactory.setConversionService((ConversionService)beanFactory.getBean("conversionService", ConversionService.class));
        }

        if (!beanFactory.hasEmbeddedValueResolver()) {
            beanFactory.addEmbeddedValueResolver((strVal) -> {
                return this.getEnvironment().resolvePlaceholders(strVal);
            });
        }

        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
        String[] var3 = weaverAwareNames;
        int var4 = weaverAwareNames.length;

        for(int var5 = 0; var5 < var4; ++var5) {
            String weaverAwareName = var3[var5];
            this.getBean(weaverAwareName);
        }

        beanFactory.setTempClassLoader((ClassLoader)null);
        beanFactory.freezeConfiguration();
        beanFactory.preInstantiateSingletons();
    }
```
`beanFactory.preInstantiateSingletons();`此行实例化所有的单例，非Lazy的。
进入此方法：
```java
public void preInstantiateSingletons() throws BeansException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Pre-instantiating singletons in " + this);
        }

        List<String> beanNames = new ArrayList(this.beanDefinitionNames);
        Iterator var2 = beanNames.iterator();

        while(true) {
            String beanName;
            Object bean;
            do {
                while(true) {
                    RootBeanDefinition bd;
                    do {
                        do {
                            do {
                                if (!var2.hasNext()) {
                                    var2 = beanNames.iterator();

                                    while(var2.hasNext()) {
                                        beanName = (String)var2.next();
                                        Object singletonInstance = this.getSingleton(beanName);
                                        if (singletonInstance instanceof SmartInitializingSingleton) {
                                            StartupStep smartInitialize = this.getApplicationStartup().start("spring.beans.smart-initialize").tag("beanName", beanName);
                                            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;
                                            if (System.getSecurityManager() != null) {
                                                AccessController.doPrivileged(() -> {
                                                    smartSingleton.afterSingletonsInstantiated();
                                                    return null;
                                                }, this.getAccessControlContext());
                                            } else {
                                                smartSingleton.afterSingletonsInstantiated();
                                            }

                                            smartInitialize.end();
                                        }
                                    }

                                    return;
                                }

                                beanName = (String)var2.next();
                                bd = this.getMergedLocalBeanDefinition(beanName);
                            } while(bd.isAbstract());
                        } while(!bd.isSingleton());
                    } while(bd.isLazyInit());

                    if (this.isFactoryBean(beanName)) {
                        bean = this.getBean("&" + beanName);
                        break;
                    }

                    this.getBean(beanName);
                }
            } while(!(bean instanceof FactoryBean));

            FactoryBean<?> factory = (FactoryBean)bean;
            boolean isEagerInit;
            if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                SmartFactoryBean var10000 = (SmartFactoryBean)factory;
                ((SmartFactoryBean)factory).getClass();
                isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, this.getAccessControlContext());
            } else {
                isEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean)factory).isEagerInit();
            }

            if (isEagerInit) {
                this.getBean(beanName);
            }
        }
    }
```
此方法，在遍历`BeanDefinition`对象，来验证这些`BeanDefinition`对象是不是可以将这些描述的bean实例化，因为有些非单例的bean，接下来不应该实例化的，所以有这么一个校验的过程。
接下来：进入此方法：`this.getBean(beanName);`
最核心的方法：
```java
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
        String beanName = this.transformedBeanName(name);
        Object sharedInstance = this.getSingleton(beanName);
        Object beanInstance;
        if (sharedInstance != null && args == null) {
            if (this.logger.isTraceEnabled()) {
                if (this.isSingletonCurrentlyInCreation(beanName)) {
                    this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
                } else {
                    this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
                }
            }

            beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
        } else {
            if (this.isPrototypeCurrentlyInCreation(beanName)) {
                throw new BeanCurrentlyInCreationException(beanName);
            }

            BeanFactory parentBeanFactory = this.getParentBeanFactory();
            if (parentBeanFactory != null && !this.containsBeanDefinition(beanName)) {
                String nameToLookup = this.originalBeanName(name);
                if (parentBeanFactory instanceof AbstractBeanFactory) {
                    return ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
                }

                if (args != null) {
                    return parentBeanFactory.getBean(nameToLookup, args);
                }

                if (requiredType != null) {
                    return parentBeanFactory.getBean(nameToLookup, requiredType);
                }

                return parentBeanFactory.getBean(nameToLookup);
            }

            if (!typeCheckOnly) {
                this.markBeanAsCreated(beanName);
            }

            StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate").tag("beanName", name);

            try {
                if (requiredType != null) {
                    beanCreation.tag("beanType", requiredType::toString);
                }

                RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);
                this.checkMergedBeanDefinition(mbd, beanName, args);
                String[] dependsOn = mbd.getDependsOn();
                String[] var12;
                if (dependsOn != null) {
                    var12 = dependsOn;
                    int var13 = dependsOn.length;

                    for(int var14 = 0; var14 < var13; ++var14) {
                        String dep = var12[var14];
                        if (this.isDependent(beanName, dep)) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                        }

                        this.registerDependentBean(dep, beanName);

                        try {
                            this.getBean(dep);
                        } catch (NoSuchBeanDefinitionException var31) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "'" + beanName + "' depends on missing bean '" + dep + "'", var31);
                        }
                    }
                }

                if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                } else if (mbd.isPrototype()) {
                    var12 = null;

                    Object prototypeInstance;
                    try {
                        this.beforePrototypeCreation(beanName);
                        prototypeInstance = this.createBean(beanName, mbd, args);
                    } finally {
                        this.afterPrototypeCreation(beanName);
                    }

                    beanInstance = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                } else {
                    String scopeName = mbd.getScope();
                    if (!StringUtils.hasLength(scopeName)) {
                        throw new IllegalStateException("No scope name defined for bean ��" + beanName + "'");
                    }

                    Scope scope = (Scope)this.scopes.get(scopeName);
                    if (scope == null) {
                        throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                    }

                    try {
                        Object scopedInstance = scope.get(beanName, () -> {
                            this.beforePrototypeCreation(beanName);

                            Object var4;
                            try {
                                var4 = this.createBean(beanName, mbd, args);
                            } finally {
                                this.afterPrototypeCreation(beanName);
                            }

                            return var4;
                        });
                        beanInstance = this.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                    } catch (IllegalStateException var30) {
                        throw new ScopeNotActiveException(beanName, scopeName, var30);
                    }
                }
            } catch (BeansException var32) {
                beanCreation.tag("exception", var32.getClass().toString());
                beanCreation.tag("message", String.valueOf(var32.getMessage()));
                this.cleanupAfterBeanCreationFailure(beanName);
                throw var32;
            } finally {
                beanCreation.end();
            }
        }

        return this.adaptBeanInstance(name, beanInstance, requiredType);
    }
```
`String beanName = this.transformedBeanName(name);`此行，先认为它是校验bean的名字是不是合法，其实还有很多其他作用；
`Object sharedInstance = this.getSingleton(beanName);`此行，是从一个map中尝试拿一下，这个bean，这个map是一个ConcurrentHashMap，是常说的Spring容器，但准确的应该叫Spring单例池，但此刻肯定是拿不到的，它为什么要拿一下呢?这里有个很关键的方法：`isSingletonCurrentlyInCreation(beanName)`
```java
String beanName = this.transformedBeanName(name);
Object sharedInstance = this.getSingleton(beanName);
Object beanInstance;
if (sharedInstance != null && args == null) {
    if (this.logger.isTraceEnabled()) {
        if (this.isSingletonCurrentlyInCreation(beanName)) {
            this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
        } else {
            this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
        }
    }

    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
}
```
至此，先跳过这部分。
再回到doGetBean方法：来到：
```java
if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    beanInstance = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }
```
此处，就要进行创建对象了：
```java
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Creating instance of bean '" + beanName + "'");
        }

        RootBeanDefinition mbdToUse = mbd;
        Class<?> resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
        if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
            mbdToUse = new RootBeanDefinition(mbd);
            mbdToUse.setBeanClass(resolvedClass);
        }

        try {
            mbdToUse.prepareMethodOverrides();
        } catch (BeanDefinitionValidationException var9) {
            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", var9);
        }

        Object beanInstance;
        try {
            beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);
            if (beanInstance != null) {
                return beanInstance;
            }
        } catch (Throwable var10) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", var10);
        }

        try {
            beanInstance = this.doCreateBean(beanName, mbdToUse, args);
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Finished creating instance of bean '" + beanName + "'");
            }

            return beanInstance;
        } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) {
            throw var7;
        } catch (Throwable var8) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", var8);
        }
    }
```
上面这段代码，可以看到，就是通过`BeanDefinition`对象拿到bean的Class类的对象出来，准备创建对象，就是拿到该类的构造器等信息，来实例化。虽然是实例化了，但并不是完整的Spring bean。如下代码片段
```java
@Component
public class OneService {
    @Autowired
    TwoService twoService;

    public OneService() {
        System.out.println("Construct OneService");
    }

    @PostConstruct
    public void aa(){
        //Spring bean生命周期初始化回调方法
        System.out.println("init");
    }

    public void getTwoService(){
        System.out.println(twoService);
    }
}
```
它这一步，仅仅是创建了OneService的基本对象，@Autowired，还有AOP功能，@PostConstruct等等都没有做，仅仅是new出来了这个基本对象。
在创建的过程中，进入doCreateBean方法中：
```java
//判断是否允许循环依赖
//主要就是this.allowCircularReferences,而Spring关闭默认允许循环依赖的关键也就是这里
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }

    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}
```
## 问题：怎么关闭Spring默认的允许循环依赖
1、直接修改源码，赋值allowCircularReferences属性为false。
2、手动refresh：
```java
//1、初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext(MyConfig.class);
//2、拿到beanFactory
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
//但这样其实没有用,因为1、步已经完成了容器的初始化。
```
正确的做法：
```java
//初始化Spring容器
AnnotationConfigApplicationContext ac =
	new AnnotationConfigApplicationContext();
//先调用默认构造器，然后自己来实现其构造器中的两个关键方法：register和refresh
ac.register(MyConfig.class);
//在此关闭循环依赖
AbstractAutowireCapableBeanFactory beanFactory =
	(AbstractAutowireCapableBeanFactory) ac.getBeanFactory();
beanFactory.setAllowCircularReferences(false);
ac.refresh();
```
回到创建过程：
```java
boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }
    //在此进行第四次后置处理器，判断是否需要AOP
    this.addSingletonFactory(beanName, () -> {
        return this.getEarlyBeanReference(beanName, mbd, bean);
    });
}

Object exposedObject = bean;

try {
    //填充属性，也就是常常说的自动注入
    //里面会完成第五次和第六次后置处理器的调用
    this.populateBean(beanName, mbd, instanceWrapper);
    //初始化bean
    //里面会完成第七次和第八次后置处理器的调用
    exposedObject = this.initializeBean(beanName, exposedObject, mbd);
} catch (Throwable var18) {
    if (var18 instanceof BeanCreationException && beanName.equals(((BeanCreationException)var18).getBeanName())) {
        throw (BeanCreationException)var18;
    }

    throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", var18);
}
```
进入populateBean方法：
```java
if (hasInstAwareBpps) {
    if (pvs == null) {
        pvs = mbd.getPropertyValues();
    }

    PropertyValues pvsToUse;
    for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {
        InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();
        pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
        if (pvsToUse == null) {
            if (filteredPds == null) {
                filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            }

            pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
                return;
            }
        }
    }
}
```
此行：`pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);`完成后，完成注入，比如TwoService，这时候就注入了进来。
注意，此处是个for循环，该循环在遍历后置处理器BeanPostProcessors，然后不同的BeanPostProcessor作不同的事情，比如常说的@Autowired注解，和@Resource注解的区别，这两个注解的组件走到这里的时候，会有不同的后置处理器来处理。
至此，来看开始循环注入的问题：
首先:初始化容器
```java
AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(MyConfig.class);
```
调用refresh方法：
```java
this.refresh();
```
经过：
```java
this.invokeBeanFactoryPostProcessors(beanFactory);
```
后完成扫描。
经过：
```java
this.finishBeanFactoryInitialization(beanFactory);
```
后完成bean的初始化。在：`this.finishBeanFactoryInitialization(beanFactory);`中，又进行了实例化所有的单例，非Lazy的bean：
```java
beanFactory.preInstantiateSingletons();
```
这里面，创建对象的过程是，先new出了基本的对象，然后接着进行属性填充：
```java
this.populateBean(beanName, mbd, instanceWrapper);
```
就是在此时，填充TwoService，这时候他会从容器中去拿TwoService这个bean，就是单例池中去拿，这时候肯定拿不到。
这时候就到了上面提到的：去池子中拿，拿不到，这时候有一个很关键的判断：
`if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName))`
```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
这个判断条件是不成立的。如果该条件成立，那么就要去三级缓存中拿。
# 循环依赖类的创建流程总结：
OK，循环依赖的两个类加载的过程：
调用构造方法new出OneService对象-->如果是单例，还会把自己放到一个代表正在创建中的Set集合中，如果开启了循环依赖，就会把当前的OneService的对象放到二级缓存中-->继续走，走到populateBean要进行填充TwoService-->从容器中找，这时候找不到。此刻就有上边这个判断，是不是正在创建的bean，如果此判断成功进入，就会从三级缓存中拿出来。-->拿不到，条件也没成立，这时候，就要new出TwoService来，当然此时new出的来TwoServcie对象，也要走bean的生命周期，那么它最终还是会走到populateBean这个方法，它也会去填充属性--->从容器中找OneService的bean，拿不到，所以它又要实例化一遍OneService，但这个过程中，但是此时有个判断条件却成立了，因为OneService确实是正在创建中，它从二级缓存中拿，是能拿到的，之前的过程存进去了。这时候，拿到OneService的对象，不等于null，就给TwoService注入了。
```java
/**
 * 比如第一次加载OneService,就会把自己放入二级缓存，当OneService进行到populateBean时，就会准备注入TwoService，
 * TwoService，也一样，最后进行到populateBean，从单例池中拿OneService，拿不到，继续从三级中拿，拿不到，继续从
 * 二级中拿，拿到了，就把OneService放进三级缓存，并将二级缓存中的移除。 
 */
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    //一级缓存：即单例池
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
        //从三级缓存中拿 
        singletonObject = this.earlySingletonObjects.get(beanName);
        //如果拿不到
        if (singletonObject == null && allowEarlyReference) {
            synchronized(this.singletonObjects) {
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        //从二级缓存中拿
                        ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                        //如果拿到了 
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            //放入三级缓存中
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            //将二级缓存中的移除
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }

    return singletonObject;
}
```
(String), 原创(String), 172(Integer), true(Boolean), true(Boolean), true(Boolean), true(Boolean), true(Boolean), 2021-04-03 01:26:55.386(Timestamp), 2021-04-04 23:40:56.51(Timestamp), 14(Long), 1(Long), 34(Long)
2021-04-25 19:13:01.858 DEBUG 19964 --- [http-nio-8080-exec-8] c.yi.blog.mapper.BlogMapper.updateById   : <==    Updates: 1
2021-04-25 19:13:01.893  INFO 19964 --- [http-nio-8080-exec-8] com.yi.blog.aspect.LogAspect             : Result:archivedetails
2021-04-25 19:19:36.756  INFO 19964 --- [http-nio-8080-exec-5] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:19:36.783 DEBUG 19964 --- [http-nio-8080-exec-5] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:19:36.784 DEBUG 19964 --- [http-nio-8080-exec-5] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:19:36.793  INFO 19964 --- [http-nio-8080-exec-9] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.post', args=[com.yi.blog.entity.Comment@6e999616, org.apache.catalina.session.StandardSessionFacade@7a3efc5b, org.apache.catalina.connector.RequestFacade@41ec18c3]}
2021-04-25 19:19:36.794 DEBUG 19964 --- [http-nio-8080-exec-5] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 0
2021-04-25 19:19:36.795  INFO 19964 --- [http-nio-8080-exec-5] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:19:36.800 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.m.RandomAvatarMapper.selectOne     : ==>  Preparing: SELECT id,avatar,user_key,create_time,update_time FROM random_avatar WHERE (user_key = ?) 
2021-04-25 19:19:36.800 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.m.RandomAvatarMapper.selectOne     : ==> Parameters: 24ae6eeb-1cb7-4fdd-8686-c5d54a37ebb3(String)
2021-04-25 19:19:36.810 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.m.RandomAvatarMapper.selectOne     : <==      Total: 0
2021-04-25 19:19:36.813 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.mapper.RandomAvatarMapper.insert   : ==>  Preparing: INSERT INTO random_avatar ( avatar, user_key, create_time, update_time ) VALUES ( ?, ?, ?, ? ) 
2021-04-25 19:19:36.813 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.mapper.RandomAvatarMapper.insert   : ==> Parameters: /images/1.svg(String), 24ae6eeb-1cb7-4fdd-8686-c5d54a37ebb3(String), 2021-04-25 19:19:36.812(Timestamp), 2021-04-25 19:19:36.81(Timestamp)
2021-04-25 19:19:36.833 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.mapper.RandomAvatarMapper.insert   : <==    Updates: 1
2021-04-25 19:19:36.839 DEBUG 19964 --- [http-nio-8080-exec-9] com.yi.blog.mapper.CommentMapper.insert  : ==>  Preparing: INSERT INTO comment ( nickname, email, content, avatar, create_time, blog_id, parent_comment_id, manager_comment ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2021-04-25 19:19:36.840 DEBUG 19964 --- [http-nio-8080-exec-9] com.yi.blog.mapper.CommentMapper.insert  : ==> Parameters: 你好(String), lyric0926@163.com(String), 11212121212(String), /images/1.svg(String), 2021-04-25 19:19:36.838(Timestamp), 37(Long), 0(Long), false(Boolean)
2021-04-25 19:19:36.859 DEBUG 19964 --- [http-nio-8080-exec-9] com.yi.blog.mapper.CommentMapper.insert  : <==    Updates: 1
2021-04-25 19:19:36.860  INFO 19964 --- [http-nio-8080-exec-9] com.yi.blog.aspect.LogAspect             : Result:redirect:/comments/37
2021-04-25 19:19:36.914  INFO 19964 --- [http-nio-8080-exec-10] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:19:36.915 DEBUG 19964 --- [http-nio-8080-exec-10] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:19:36.915 DEBUG 19964 --- [http-nio-8080-exec-10] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:19:36.925 DEBUG 19964 --- [http-nio-8080-exec-10] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 1
2021-04-25 19:19:36.926  INFO 19964 --- [http-nio-8080-exec-10] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:19:39.862  INFO 19964 --- [http-nio-8080-exec-1] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:19:39.872 DEBUG 19964 --- [http-nio-8080-exec-1] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:19:39.872 DEBUG 19964 --- [http-nio-8080-exec-1] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:19:39.881  INFO 19964 --- [http-nio-8080-exec-8] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.post', args=[com.yi.blog.entity.Comment@14bb3913, org.apache.catalina.session.StandardSessionFacade@7a3efc5b, org.apache.catalina.connector.RequestFacade@41ec18c3]}
2021-04-25 19:19:39.882 DEBUG 19964 --- [http-nio-8080-exec-8] c.y.b.m.RandomAvatarMapper.selectOne     : ==>  Preparing: SELECT id,avatar,user_key,create_time,update_time FROM random_avatar WHERE (user_key = ?) 
2021-04-25 19:19:39.883 DEBUG 19964 --- [http-nio-8080-exec-8] c.y.b.m.RandomAvatarMapper.selectOne     : ==> Parameters: 24ae6eeb-1cb7-4fdd-8686-c5d54a37ebb3(String)
2021-04-25 19:19:39.883 DEBUG 19964 --- [http-nio-8080-exec-1] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 1
2021-04-25 19:19:39.884  INFO 19964 --- [http-nio-8080-exec-1] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:19:39.893 DEBUG 19964 --- [http-nio-8080-exec-8] c.y.b.m.RandomAvatarMapper.selectOne     : <==      Total: 1
2021-04-25 19:19:39.894 DEBUG 19964 --- [http-nio-8080-exec-8] com.yi.blog.mapper.CommentMapper.insert  : ==>  Preparing: INSERT INTO comment ( nickname, email, content, avatar, create_time, blog_id, parent_comment_id, manager_comment ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2021-04-25 19:19:39.894 DEBUG 19964 --- [http-nio-8080-exec-8] com.yi.blog.mapper.CommentMapper.insert  : ==> Parameters: 你好(String), lyric0926@163.com(String), 312312312312(String), /images/1.svg(String), 2021-04-25 19:19:39.893(Timestamp), 37(Long), 0(Long), false(Boolean)
2021-04-25 19:19:39.914 DEBUG 19964 --- [http-nio-8080-exec-8] com.yi.blog.mapper.CommentMapper.insert  : <==    Updates: 1
2021-04-25 19:19:39.915  INFO 19964 --- [http-nio-8080-exec-8] com.yi.blog.aspect.LogAspect             : Result:redirect:/comments/37
2021-04-25 19:19:39.948  INFO 19964 --- [http-nio-8080-exec-4] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:19:39.949 DEBUG 19964 --- [http-nio-8080-exec-4] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:19:39.949 DEBUG 19964 --- [http-nio-8080-exec-4] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:19:39.959 DEBUG 19964 --- [http-nio-8080-exec-4] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 2
2021-04-25 19:19:39.959  INFO 19964 --- [http-nio-8080-exec-4] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:19:40.381  INFO 19964 --- [http-nio-8080-exec-3] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:19:40.382 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:19:40.383 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:19:40.393 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 2
2021-04-25 19:19:40.394  INFO 19964 --- [http-nio-8080-exec-3] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:19:42.590  INFO 19964 --- [http-nio-8080-exec-10] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:19:42.600 DEBUG 19964 --- [http-nio-8080-exec-10] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:19:42.601 DEBUG 19964 --- [http-nio-8080-exec-10] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:19:42.609  INFO 19964 --- [http-nio-8080-exec-9] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.post', args=[com.yi.blog.entity.Comment@30a16705, org.apache.catalina.session.StandardSessionFacade@7a3efc5b, org.apache.catalina.connector.RequestFacade@41ec18c3]}
2021-04-25 19:19:42.611 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.m.RandomAvatarMapper.selectOne     : ==>  Preparing: SELECT id,avatar,user_key,create_time,update_time FROM random_avatar WHERE (user_key = ?) 
2021-04-25 19:19:42.611 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.m.RandomAvatarMapper.selectOne     : ==> Parameters: 24ae6eeb-1cb7-4fdd-8686-c5d54a37ebb3(String)
2021-04-25 19:19:42.611 DEBUG 19964 --- [http-nio-8080-exec-10] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 2
2021-04-25 19:19:42.611  INFO 19964 --- [http-nio-8080-exec-10] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:19:42.621 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.m.RandomAvatarMapper.selectOne     : <==      Total: 1
2021-04-25 19:19:42.621 DEBUG 19964 --- [http-nio-8080-exec-9] com.yi.blog.mapper.CommentMapper.insert  : ==>  Preparing: INSERT INTO comment ( nickname, email, content, avatar, create_time, blog_id, parent_comment_id, manager_comment ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2021-04-25 19:19:42.622 DEBUG 19964 --- [http-nio-8080-exec-9] com.yi.blog.mapper.CommentMapper.insert  : ==> Parameters: 你好(String), lyric0926@163.com(String), 2`1231231312312(String), /images/1.svg(String), 2021-04-25 19:19:42.621(Timestamp), 37(Long), 0(Long), false(Boolean)
2021-04-25 19:19:42.641 DEBUG 19964 --- [http-nio-8080-exec-9] com.yi.blog.mapper.CommentMapper.insert  : <==    Updates: 1
2021-04-25 19:19:42.642  INFO 19964 --- [http-nio-8080-exec-9] com.yi.blog.aspect.LogAspect             : Result:redirect:/comments/37
2021-04-25 19:19:42.676  INFO 19964 --- [http-nio-8080-exec-1] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:19:42.677 DEBUG 19964 --- [http-nio-8080-exec-1] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:19:42.677 DEBUG 19964 --- [http-nio-8080-exec-1] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:19:42.687 DEBUG 19964 --- [http-nio-8080-exec-1] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 3
2021-04-25 19:19:42.687  INFO 19964 --- [http-nio-8080-exec-1] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:19:46.221  INFO 19964 --- [http-nio-8080-exec-4] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:19:46.232 DEBUG 19964 --- [http-nio-8080-exec-4] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:19:46.232 DEBUG 19964 --- [http-nio-8080-exec-4] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:19:46.239  INFO 19964 --- [http-nio-8080-exec-8] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.post', args=[com.yi.blog.entity.Comment@70b057cd, org.apache.catalina.session.StandardSessionFacade@7a3efc5b, org.apache.catalina.connector.RequestFacade@41ec18c3]}
2021-04-25 19:19:46.240 DEBUG 19964 --- [http-nio-8080-exec-8] c.y.b.m.RandomAvatarMapper.selectOne     : ==>  Preparing: SELECT id,avatar,user_key,create_time,update_time FROM random_avatar WHERE (user_key = ?) 
2021-04-25 19:19:46.240 DEBUG 19964 --- [http-nio-8080-exec-8] c.y.b.m.RandomAvatarMapper.selectOne     : ==> Parameters: 24ae6eeb-1cb7-4fdd-8686-c5d54a37ebb3(String)
2021-04-25 19:19:46.244 DEBUG 19964 --- [http-nio-8080-exec-4] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 3
2021-04-25 19:19:46.244  INFO 19964 --- [http-nio-8080-exec-4] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:19:46.250 DEBUG 19964 --- [http-nio-8080-exec-8] c.y.b.m.RandomAvatarMapper.selectOne     : <==      Total: 1
2021-04-25 19:19:46.251 DEBUG 19964 --- [http-nio-8080-exec-8] com.yi.blog.mapper.CommentMapper.insert  : ==>  Preparing: INSERT INTO comment ( nickname, email, content, avatar, create_time, blog_id, parent_comment_id, manager_comment ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2021-04-25 19:19:46.251 DEBUG 19964 --- [http-nio-8080-exec-8] com.yi.blog.mapper.CommentMapper.insert  : ==> Parameters: 你好(String), lyric0926@163.com(String), 123123241241241241212(String), /images/1.svg(String), 2021-04-25 19:19:46.251(Timestamp), 37(Long), 0(Long), false(Boolean)
2021-04-25 19:19:46.270 DEBUG 19964 --- [http-nio-8080-exec-8] com.yi.blog.mapper.CommentMapper.insert  : <==    Updates: 1
2021-04-25 19:19:46.271  INFO 19964 --- [http-nio-8080-exec-8] com.yi.blog.aspect.LogAspect             : Result:redirect:/comments/37
2021-04-25 19:19:46.307  INFO 19964 --- [http-nio-8080-exec-3] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:19:46.308 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:19:46.308 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:19:46.320 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 4
2021-04-25 19:19:46.320  INFO 19964 --- [http-nio-8080-exec-3] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:19:51.693  INFO 19964 --- [http-nio-8080-exec-2] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:19:51.704 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:19:51.704 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:19:51.715  INFO 19964 --- [http-nio-8080-exec-10] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.post', args=[com.yi.blog.entity.Comment@56399a39, org.apache.catalina.session.StandardSessionFacade@7a3efc5b, org.apache.catalina.connector.RequestFacade@41ec18c3]}
2021-04-25 19:19:51.715 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 4
2021-04-25 19:19:51.716  INFO 19964 --- [http-nio-8080-exec-2] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:19:51.716 DEBUG 19964 --- [http-nio-8080-exec-10] c.y.b.m.RandomAvatarMapper.selectOne     : ==>  Preparing: SELECT id,avatar,user_key,create_time,update_time FROM random_avatar WHERE (user_key = ?) 
2021-04-25 19:19:51.716 DEBUG 19964 --- [http-nio-8080-exec-10] c.y.b.m.RandomAvatarMapper.selectOne     : ==> Parameters: 24ae6eeb-1cb7-4fdd-8686-c5d54a37ebb3(String)
2021-04-25 19:19:51.727 DEBUG 19964 --- [http-nio-8080-exec-10] c.y.b.m.RandomAvatarMapper.selectOne     : <==      Total: 1
2021-04-25 19:19:51.729 DEBUG 19964 --- [http-nio-8080-exec-10] com.yi.blog.mapper.CommentMapper.insert  : ==>  Preparing: INSERT INTO comment ( nickname, email, content, avatar, create_time, blog_id, parent_comment_id, manager_comment ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2021-04-25 19:19:51.729 DEBUG 19964 --- [http-nio-8080-exec-10] com.yi.blog.mapper.CommentMapper.insert  : ==> Parameters: 你好(String), lyric0926@163.com(String), 11111111111111111111111111111111111111111111111111111111(String), /images/1.svg(String), 2021-04-25 19:19:51.728(Timestamp), 37(Long), 0(Long), false(Boolean)
2021-04-25 19:19:51.748 DEBUG 19964 --- [http-nio-8080-exec-10] com.yi.blog.mapper.CommentMapper.insert  : <==    Updates: 1
2021-04-25 19:19:51.748  INFO 19964 --- [http-nio-8080-exec-10] com.yi.blog.aspect.LogAspect             : Result:redirect:/comments/37
2021-04-25 19:19:51.782  INFO 19964 --- [http-nio-8080-exec-1] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:19:51.783 DEBUG 19964 --- [http-nio-8080-exec-1] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:19:51.783 DEBUG 19964 --- [http-nio-8080-exec-1] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:19:51.793 DEBUG 19964 --- [http-nio-8080-exec-1] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 5
2021-04-25 19:19:51.793  INFO 19964 --- [http-nio-8080-exec-1] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:19:51.801  INFO 19964 --- [http-nio-8080-exec-4] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:19:51.802 DEBUG 19964 --- [http-nio-8080-exec-4] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:19:51.802 DEBUG 19964 --- [http-nio-8080-exec-4] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:19:51.810  INFO 19964 --- [http-nio-8080-exec-7] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.post', args=[com.yi.blog.entity.Comment@586269e6, org.apache.catalina.session.StandardSessionFacade@7a3efc5b, org.apache.catalina.connector.RequestFacade@41ec18c3]}
2021-04-25 19:19:51.811 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.RandomAvatarMapper.selectOne     : ==>  Preparing: SELECT id,avatar,user_key,create_time,update_time FROM random_avatar WHERE (user_key = ?) 
2021-04-25 19:19:51.812 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.RandomAvatarMapper.selectOne     : ==> Parameters: 24ae6eeb-1cb7-4fdd-8686-c5d54a37ebb3(String)
2021-04-25 19:19:51.812 DEBUG 19964 --- [http-nio-8080-exec-4] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 5
2021-04-25 19:19:51.813  INFO 19964 --- [http-nio-8080-exec-4] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:19:51.822 DEBUG 19964 --- [http-nio-8080-exec-7] c.y.b.m.RandomAvatarMapper.selectOne     : <==      Total: 1
2021-04-25 19:19:51.824 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.CommentMapper.insert  : ==>  Preparing: INSERT INTO comment ( nickname, email, content, avatar, create_time, blog_id, parent_comment_id, manager_comment ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2021-04-25 19:19:51.824 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.CommentMapper.insert  : ==> Parameters: 你好(String), lyric0926@163.com(String), 11111111111111111111111111111111111111111111111111111111(String), /images/1.svg(String), 2021-04-25 19:19:51.823(Timestamp), 37(Long), 0(Long), false(Boolean)
2021-04-25 19:19:51.843 DEBUG 19964 --- [http-nio-8080-exec-7] com.yi.blog.mapper.CommentMapper.insert  : <==    Updates: 1
2021-04-25 19:19:51.843  INFO 19964 --- [http-nio-8080-exec-7] com.yi.blog.aspect.LogAspect             : Result:redirect:/comments/37
2021-04-25 19:19:51.876  INFO 19964 --- [http-nio-8080-exec-3] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:19:51.877 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:19:51.878 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:19:51.887 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 6
2021-04-25 19:19:51.887  INFO 19964 --- [http-nio-8080-exec-3] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:19:55.848  INFO 19964 --- [http-nio-8080-exec-9] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:19:55.857 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:19:55.857 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:19:55.866  INFO 19964 --- [http-nio-8080-exec-2] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.post', args=[com.yi.blog.entity.Comment@5599bf37, org.apache.catalina.session.StandardSessionFacade@7a3efc5b, org.apache.catalina.connector.RequestFacade@41ec18c3]}
2021-04-25 19:19:55.868 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.m.RandomAvatarMapper.selectOne     : ==>  Preparing: SELECT id,avatar,user_key,create_time,update_time FROM random_avatar WHERE (user_key = ?) 
2021-04-25 19:19:55.868 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.m.RandomAvatarMapper.selectOne     : ==> Parameters: 24ae6eeb-1cb7-4fdd-8686-c5d54a37ebb3(String)
2021-04-25 19:19:55.869 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 6
2021-04-25 19:19:55.869  INFO 19964 --- [http-nio-8080-exec-9] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:19:55.878 DEBUG 19964 --- [http-nio-8080-exec-2] c.y.b.m.RandomAvatarMapper.selectOne     : <==      Total: 1
2021-04-25 19:19:55.879 DEBUG 19964 --- [http-nio-8080-exec-2] com.yi.blog.mapper.CommentMapper.insert  : ==>  Preparing: INSERT INTO comment ( nickname, email, content, avatar, create_time, blog_id, parent_comment_id, manager_comment ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2021-04-25 19:19:55.880 DEBUG 19964 --- [http-nio-8080-exec-2] com.yi.blog.mapper.CommentMapper.insert  : ==> Parameters: 你好(String), lyric0926@163.com(String), 122222222222222222222222222222222222222222222(String), /images/1.svg(String), 2021-04-25 19:19:55.879(Timestamp), 37(Long), 0(Long), false(Boolean)
2021-04-25 19:19:55.898 DEBUG 19964 --- [http-nio-8080-exec-2] com.yi.blog.mapper.CommentMapper.insert  : <==    Updates: 1
2021-04-25 19:19:55.899  INFO 19964 --- [http-nio-8080-exec-2] com.yi.blog.aspect.LogAspect             : Result:redirect:/comments/37
2021-04-25 19:19:55.933  INFO 19964 --- [http-nio-8080-exec-1] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:19:55.934 DEBUG 19964 --- [http-nio-8080-exec-1] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:19:55.934 DEBUG 19964 --- [http-nio-8080-exec-1] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:19:55.945 DEBUG 19964 --- [http-nio-8080-exec-1] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 7
2021-04-25 19:19:55.945  INFO 19964 --- [http-nio-8080-exec-1] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:20:01.263  INFO 19964 --- [http-nio-8080-exec-8] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:20:01.273 DEBUG 19964 --- [http-nio-8080-exec-8] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:20:01.273 DEBUG 19964 --- [http-nio-8080-exec-8] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:20:01.281  INFO 19964 --- [http-nio-8080-exec-4] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.post', args=[com.yi.blog.entity.Comment@7c7dbe1c, org.apache.catalina.session.StandardSessionFacade@7a3efc5b, org.apache.catalina.connector.RequestFacade@41ec18c3]}
2021-04-25 19:20:01.282 DEBUG 19964 --- [http-nio-8080-exec-4] c.y.b.m.RandomAvatarMapper.selectOne     : ==>  Preparing: SELECT id,avatar,user_key,create_time,update_time FROM random_avatar WHERE (user_key = ?) 
2021-04-25 19:20:01.283 DEBUG 19964 --- [http-nio-8080-exec-4] c.y.b.m.RandomAvatarMapper.selectOne     : ==> Parameters: 24ae6eeb-1cb7-4fdd-8686-c5d54a37ebb3(String)
2021-04-25 19:20:01.284 DEBUG 19964 --- [http-nio-8080-exec-8] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 7
2021-04-25 19:20:01.284  INFO 19964 --- [http-nio-8080-exec-8] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:20:01.293 DEBUG 19964 --- [http-nio-8080-exec-4] c.y.b.m.RandomAvatarMapper.selectOne     : <==      Total: 1
2021-04-25 19:20:01.294 DEBUG 19964 --- [http-nio-8080-exec-4] com.yi.blog.mapper.CommentMapper.insert  : ==>  Preparing: INSERT INTO comment ( nickname, email, content, avatar, create_time, blog_id, parent_comment_id, manager_comment ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2021-04-25 19:20:01.294 DEBUG 19964 --- [http-nio-8080-exec-4] com.yi.blog.mapper.CommentMapper.insert  : ==> Parameters: 你好(String), lyric0926@163.com(String), 1212111111111(String), /images/1.svg(String), 2021-04-25 19:20:01.293(Timestamp), 37(Long), 0(Long), false(Boolean)
2021-04-25 19:20:01.314 DEBUG 19964 --- [http-nio-8080-exec-4] com.yi.blog.mapper.CommentMapper.insert  : <==    Updates: 1
2021-04-25 19:20:01.314  INFO 19964 --- [http-nio-8080-exec-4] com.yi.blog.aspect.LogAspect             : Result:redirect:/comments/37
2021-04-25 19:20:01.347  INFO 19964 --- [http-nio-8080-exec-3] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:20:01.348 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:20:01.348 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:20:01.360 DEBUG 19964 --- [http-nio-8080-exec-3] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 8
2021-04-25 19:20:01.360  INFO 19964 --- [http-nio-8080-exec-3] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:20:08.628  INFO 19964 --- [http-nio-8080-exec-10] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:20:08.638 DEBUG 19964 --- [http-nio-8080-exec-10] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:20:08.638 DEBUG 19964 --- [http-nio-8080-exec-10] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:20:08.646  INFO 19964 --- [http-nio-8080-exec-9] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.post', args=[com.yi.blog.entity.Comment@202020c2, org.apache.catalina.session.StandardSessionFacade@7a3efc5b, org.apache.catalina.connector.RequestFacade@41ec18c3]}
2021-04-25 19:20:08.648 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.m.RandomAvatarMapper.selectOne     : ==>  Preparing: SELECT id,avatar,user_key,create_time,update_time FROM random_avatar WHERE (user_key = ?) 
2021-04-25 19:20:08.648 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.m.RandomAvatarMapper.selectOne     : ==> Parameters: 24ae6eeb-1cb7-4fdd-8686-c5d54a37ebb3(String)
2021-04-25 19:20:08.652 DEBUG 19964 --- [http-nio-8080-exec-10] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 8
2021-04-25 19:20:08.653  INFO 19964 --- [http-nio-8080-exec-10] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:20:08.658 DEBUG 19964 --- [http-nio-8080-exec-9] c.y.b.m.RandomAvatarMapper.selectOne     : <==      Total: 1
2021-04-25 19:20:08.659 DEBUG 19964 --- [http-nio-8080-exec-9] com.yi.blog.mapper.CommentMapper.insert  : ==>  Preparing: INSERT INTO comment ( nickname, email, content, avatar, create_time, blog_id, parent_comment_id, manager_comment ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? ) 
2021-04-25 19:20:08.660 DEBUG 19964 --- [http-nio-8080-exec-9] com.yi.blog.mapper.CommentMapper.insert  : ==> Parameters: 你好(String), lyric0926@163.com(String), 11111111111111111111111(String), /images/1.svg(String), 2021-04-25 19:20:08.659(Timestamp), 37(Long), 0(Long), false(Boolean)
2021-04-25 19:20:08.678 DEBUG 19964 --- [http-nio-8080-exec-9] com.yi.blog.mapper.CommentMapper.insert  : <==    Updates: 1
2021-04-25 19:20:08.679  INFO 19964 --- [http-nio-8080-exec-9] com.yi.blog.aspect.LogAspect             : Result:redirect:/comments/37
2021-04-25 19:20:08.711  INFO 19964 --- [http-nio-8080-exec-1] com.yi.blog.aspect.LogAspect             : requestLog:RequestLog{uri='http://localhost:8080/comments/37', ip='0:0:0:0:0:0:0:1', classMethod='com.yi.blog.web.CommentController.comments', args=[37, {}]}
2021-04-25 19:20:08.712 DEBUG 19964 --- [http-nio-8080-exec-1] c.y.b.mapper.CommentMapper.selectList    : ==>  Preparing: SELECT id,nickname,email,content,avatar,create_time,blog_id,parent_comment_id,manager_comment FROM comment WHERE (blog_id = ?) ORDER BY create_time DESC 
2021-04-25 19:20:08.713 DEBUG 19964 --- [http-nio-8080-exec-1] c.y.b.mapper.CommentMapper.selectList    : ==> Parameters: 37(Long)
2021-04-25 19:20:08.725 DEBUG 19964 --- [http-nio-8080-exec-1] c.y.b.mapper.CommentMapper.selectList    : <==      Total: 9
2021-04-25 19:20:08.726  INFO 19964 --- [http-nio-8080-exec-1] com.yi.blog.aspect.LogAspect             : Result:archivedetails :: commentList
2021-04-25 19:37:09.647  INFO 19964 --- [Thread-16] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
2021-04-25 19:37:09.648  INFO 19964 --- [Thread-16] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...
2021-04-25 19:37:09.653  INFO 19964 --- [Thread-16] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.
